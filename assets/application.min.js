/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(1);


/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

	var App = __webpack_require__(2),
	    data = __webpack_require__(117),
	    app = new App({
	        data: data
	    });

	window.app = app;

	document.body.appendChild(app.element);


/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

	var CustomElement = __webpack_require__(3),
	    BrowserRouter = __webpack_require__(106);

	var App = CustomElement.createElement({
	    template: __webpack_require__(111),
	    partials: {
	        issue: __webpack_require__(112),
	        header: __webpack_require__(114),
	        sidebar: __webpack_require__(115),
	        stances: __webpack_require__(116),
	        stance: __webpack_require__(118)
	    },
	    transforms: {
	        any: function any(obj) {
	            return typeof obj === 'object' && Object.keys(obj).length;
	        },
	        empty: function empty(obj) {
	            return typeof obj !== 'object' || !Object.keys(obj).length;
	        }
	    }
	}, function App(options) {
	    var _ = this,
	        $ = window.jQuery.noConflict();

	    CustomElement.call(_, options || {});

	    var $el = $(_.element),
	        router = new BrowserRouter({
	            mode: 'hash'
	        });

	    router.set404({
	        title: 'Gov.Vote',
	        handler: function (req) {
	            var params = req.fullPath.split(/\//);

	            _.setSite((params[1] + '').replace(/^#/, ''), (params[2] + '').replace(/^#/, ''));

	            var issue = _.get('site.issues.' + params[3]) || _.get('site');

	            _.set('issue', issue);

	            if (issue.stances && issue.stances[params[4]]) {
	                _.set('stance', issue.stances[params[4]]);
	            } else {
	                _.unset('stance');
	            }

	            document.body.scrollTop = 0;
	        }
	    });

	    router.start();

	    $el.on('click', '[href][href!="#"]', function() {
	        router.go( $(this).attr('href').replace(/^#/, '') );

	        if ($(this).closest('sidebar').length) {
	            if (parseInt($(this).closest('sidebar').css('width')) !== 280) {
	                $('sidebar').animate({ left: '-100%' }, 150);
	            }
	        }

	        return false;
	    });

	    $el.on('click', '.toggle-sidebar', function() {
	        $('sidebar').animate({ left: 0 }, 150);
	        return false;
	    });
	});

	App.definePrototype({
	    setSite: function setSite(lang, permalink) {
	        var _ = this,
	            site = _.get(permalink + '.' + lang);

	        if (!site) {
	            _.setSite('en', 'ca');
	        } else {
	            _.set('site', site);
	            _.set('prefix', '/' + lang + '/' + permalink);
	        }
	    },
	});

	module.exports = App;


/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

	var CustomElement = __webpack_require__(4);

	if (typeof window !== 'undefined') {
	    window.CustomElement = CustomElement;
	}

	module.exports = CustomElement;


/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

	var Store = __webpack_require__(5),
	    createElement = __webpack_require__(8);

	var CustomElement = Store.generate(function CustomElement(options) {
	    var _ = this;

	    Store.call(_, typeof options === 'object' ? options.data : {});

	    var dom = _.bars.build(_.bars.preCompile(options.template || _.template, 'index', null, {
	        minify: true
	    }), _._data);

	    _.defineProperties({
	        element: dom.rootNode,
	        dom: dom
	    });

	    _.on('update', function() {
	        _.update();
	    });

	    _.update();
	});

	CustomElement.createElement = createElement;

	CustomElement.definePrototype({
	    update: function update() {
	        var _ = this;
	        _.dom.update(_._data);
	    }
	});

	module.exports = CustomElement;


/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

	var Generator = __webpack_require__(6),
	    events = __webpack_require__(7);

	var Store = Generator.generateFrom(events.EventEmitter, function Store(data) {
	    var _ = this;

	    _.defineProperties({
	        _data: data || {}
	    });
	});

	Store.definePrototype({
	    set: function set(key, value) {
	        this._data = typeof this._data === 'object' ? this._data : {};

	        var _ = this,
	            splat = key.split(/\/|\./),
	            lastKey = splat.pop(),
	            obj = _._data;

	        for (var i = 0; i < splat.length; i++) {
	            if (typeof obj[splat[i]] !== 'object') {
	                obj[splat[i]] = {};
	            }

	            obj = obj[splat[i]];
	        }

	        obj[lastKey] = value;

	        _.emit('update', key, value);

	        return value;
	    },

	    unset: function unset(key) {
	        this._data = typeof this._data === 'object' ? this._data : {};

	        var _ = this,
	            splat = key.split(/\/|\./),
	            lastKey = splat.pop(),
	            obj = _._data;

	        for (var i = 0; i < splat.length; i++) {
	            if (typeof obj[splat[i]] !== 'object') {
	                obj[splat[i]] = {};
	            }

	            obj = obj[splat[i]];
	        }

	        delete obj[lastKey];

	        obj = _._data;

	        for (i = 0; i < splat.length; i++) {
	            if (typeof obj[splat[i]] === 'object' && !Object.keys(obj[splat[i]]).length) {
	                delete obj[splat[i]];
	                break;
	            }

	            obj = obj[splat[i]];
	        }

	        _.emit('update', key);
	    },

	    get: function get(key) {
	        var _ = this,
	            splat = key.split(/\/|\./),
	            lastKey = splat.pop(),
	            obj = _._data;

	        for (var i = 0; i < splat.length; i++) {
	            obj = obj[splat[i]];
	            if (!obj) return;
	        }

	        return obj[lastKey];
	    },

	    push: function push(key, value) {
	        var _ = this,
	            arr = _.get(key);

	        if (arr instanceof Array) {
	            arr.push(value);
	            _.set(key, arr);
	        } else {
	            _.set(key, [value]);
	        }
	    }
	});

	module.exports = Store;


/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/**
	 * @name generate.js
	 * @author Michaelangelo Jong
	 */

	(function GeneratorScope() {
	    /**
	     * Assert Error function.
	     * @param  {Boolean} condition Whether or not to throw error.
	     * @param  {String} message    Error message.
	     */
	    function assertError(condition, message) {
	        if (!condition) {
	            throw new Error(message);
	        }
	    }

	    /**
	     * Assert TypeError function.
	     * @param  {Boolean} condition Whether or not to throw error.
	     * @param  {String} message    Error message.
	     */
	    function assertTypeError(test, type) {
	        if (typeof test !== type) {
	            throw new TypeError('Expected \'' + type +
	                '\' but instead found \'' +
	                typeof test + '\'');
	        }
	    }

	    /**
	     * Returns the name of function 'func'.
	     * @param  {Function} func Any function.
	     * @return {String}        Name of 'func'.
	     */
	    function getFunctionName(func) {
	        if (func.name !== void(0)) {
	            return func.name;
	        }
	        // Else use IE Shim
	        var funcNameMatch = func.toString()
	            .match(/function\s*([^\s]*)\s*\(/);
	        func.name = (funcNameMatch && funcNameMatch[1]) || '';
	        return func.name;
	    }

	    /**
	     * Returns true if 'obj' is an object containing only get and set functions, false otherwise.
	     * @param  {Any} obj Value to be tested.
	     * @return {Boolean} true or false.
	     */
	    function isGetSet(obj) {
	        var keys, length;
	        if (obj && typeof obj === 'object') {
	            keys = Object.getOwnPropertyNames(obj)
	                .sort();
	            length = keys.length;

	            if ((length === 1 && (keys[0] === 'get' && typeof obj.get ===
	                    'function' ||
	                    keys[0] === 'set' && typeof obj.set === 'function'
	                )) ||
	                (length === 2 && (keys[0] === 'get' && typeof obj.get ===
	                    'function' &&
	                    keys[1] === 'set' && typeof obj.set === 'function'
	                ))) {
	                return true;
	            }
	        }
	        return false;
	    }

	    /**
	     * Defines properties on 'obj'.
	     * @param  {Object} obj        An object that 'properties' will be attached to.
	     * @param  {Object} descriptor Optional object descriptor that will be applied to all attaching properties on 'properties'.
	     * @param  {Object} properties An object who's properties will be attached to 'obj'.
	     * @return {Generator}         'obj'.
	     */
	    function defineObjectProperties(obj, descriptor, properties) {
	        var setProperties = {},
	            i,
	            keys,
	            length,

	            p = properties || descriptor,
	            d = properties && descriptor;

	        properties = (p && typeof p === 'object') ? p : {};
	        descriptor = (d && typeof d === 'object') ? d : {};

	        keys = Object.getOwnPropertyNames(properties);
	        length = keys.length;

	        for (i = 0; i < length; i++) {
	            if (isGetSet(properties[keys[i]])) {
	                setProperties[keys[i]] = {
	                    configurable: !!descriptor.configurable,
	                    enumerable: !!descriptor.enumerable,
	                    get: properties[keys[i]].get,
	                    set: properties[keys[i]].set
	                };
	            } else {
	                setProperties[keys[i]] = {
	                    configurable: !!descriptor.configurable,
	                    enumerable: !!descriptor.enumerable,
	                    writable: !!descriptor.writable,
	                    value: properties[keys[i]]
	                };
	            }
	        }
	        Object.defineProperties(obj, setProperties);
	        return obj;
	    }



	    var Creation = {
	        /**
	         * Defines properties on this object.
	         * @param  {Object} descriptor Optional object descriptor that will be applied to all attaching properties.
	         * @param  {Object} properties An object who's properties will be attached to this object.
	         * @return {Object}            This object.
	         */
	        defineProperties: function defineProperties(descriptor,
	            properties) {
	            defineObjectProperties(this, descriptor,
	                properties);
	            return this;
	        },

	        /**
	         * returns the prototype of `this` Creation.
	         * @return {Object} Prototype of `this` Creation.
	         */
	        getProto: function getProto() {
	            return Object.getPrototypeOf(this);
	        },

	        /**
	         * returns the prototype of `this` super Creation.
	         * @return {Object} Prototype of `this` super Creation.
	         */
	        getSuper: function getSuper() {
	            return Object.getPrototypeOf(this.constructor.prototype);
	        }
	    };

	    var Generation = {
	        /**
	         * Returns true if 'generator' was generated by this Generator.
	         * @param  {Generator} generator A Generator.
	         * @return {Boolean}             true or false.
	         */
	        isGeneration: function isGeneration(generator) {
	            assertTypeError(generator, 'function');

	            var _ = this;

	            return _.prototype.isPrototypeOf(generator.prototype);
	        },

	        /**
	         * Returns true if 'object' was created by this Generator.
	         * @param  {Object} object An Object.
	         * @return {Boolean}       true or false.
	         */
	        isCreation: function isCreation(object) {
	            var _ = this;
	            return object instanceof _;
	        },
	        /**
	         * Generates a new generator that inherits from `this` generator.
	         * @param {Generator} ParentGenerator Generator to inherit from.
	         * @param {Function} create           Create method that gets called when creating a new instance of new generator.
	         * @return {Generator}                New Generator that inherits from 'ParentGenerator'.
	         */
	        generate: function generate(construct) {
	            assertTypeError(construct, 'function');

	            var _ = this;

	            defineObjectProperties(
	                construct, {
	                    configurable: false,
	                    enumerable: false,
	                    writable: false
	                }, {
	                    prototype: Object.create(_.prototype)
	                }
	            );

	            defineObjectProperties(
	                construct, {
	                    configurable: false,
	                    enumerable: false,
	                    writable: false
	                },
	                Generation
	            );

	            defineObjectProperties(
	                construct.prototype, {
	                    configurable: false,
	                    enumerable: false,
	                    writable: false
	                }, {
	                    constructor: construct,
	                    generator: construct,
	                }
	            );

	            return construct;
	        },

	        /**
	         * Defines shared properties for all objects created by this generator.
	         * @param  {Object} descriptor Optional object descriptor that will be applied to all attaching properties.
	         * @param  {Object} properties An object who's properties will be attached to this generator's prototype.
	         * @return {Generator}         This generator.
	         */
	        definePrototype: function definePrototype(descriptor,
	            properties) {
	            defineObjectProperties(this.prototype,
	                descriptor,
	                properties);
	            return this;
	        }
	    };

	    function Generator() {}

	    defineObjectProperties(
	        Generator, {
	            configurable: false,
	            enumerable: false,
	            writable: false
	        }, {
	            prototype: Generator.prototype
	        }
	    );

	    defineObjectProperties(
	        Generator.prototype, {
	            configurable: false,
	            enumerable: false,
	            writable: false
	        },
	        Creation
	    );

	    defineObjectProperties(
	        Generator, {
	            configurable: false,
	            enumerable: false,
	            writable: false
	        },
	        Generation
	    );

	    defineObjectProperties(
	        Generator, {
	            configurable: false,
	            enumerable: false,
	            writable: false
	        }, {
	            /**
	             * Returns true if 'generator' was generated by this Generator.
	             * @param  {Generator} generator A Generator.
	             * @return {Boolean}             true or false.
	             */
	            isGenerator: function isGenerator(generator) {
	                return this.isGeneration(generator);
	            },

	            /**
	             * Generates a new generator that inherits from `this` generator.
	             * @param {Generator} extendFrom      Constructor to inherit from.
	             * @param {Function} create           Create method that gets called when creating a new instance of new generator.
	             * @return {Generator}                New Generator that inherits from 'ParentGenerator'.
	             */
	            toGenerator: function toGenerator(extendFrom, create) {
	                console.warn(
	                    'Generator.toGenerator is depreciated please use Generator.generateFrom'
	                );
	                return this.generateFrom(extendFrom, create);
	            },

	            /**
	             * Generates a new generator that inherits from `this` generator.
	             * @param {Constructor} extendFrom    Constructor to inherit from.
	             * @param {Function} create           Create method that gets called when creating a new instance of new generator.
	             * @return {Generator}                New Generator that inherits from 'ParentGenerator'.
	             */
	            generateFrom: function generateFrom(extendFrom, create) {
	                assertTypeError(extendFrom, 'function');
	                assertTypeError(create, 'function');

	                defineObjectProperties(
	                    create, {
	                        configurable: false,
	                        enumerable: false,
	                        writable: false
	                    }, {
	                        prototype: Object.create(extendFrom.prototype),
	                    }
	                );

	                defineObjectProperties(
	                    create, {
	                        configurable: false,
	                        enumerable: false,
	                        writable: false
	                    },
	                    Generation
	                );

	                defineObjectProperties(
	                    create.prototype, {
	                        configurable: false,
	                        enumerable: false,
	                        writable: false
	                    }, {
	                        constructor: create,
	                        generator: create,
	                    }
	                );

	                defineObjectProperties(
	                    create.prototype, {
	                        configurable: false,
	                        enumerable: false,
	                        writable: false
	                    },
	                    Creation
	                );

	                return create;
	            }
	        }
	    );

	    Object.freeze(Generator);
	    Object.freeze(Generator.prototype);

	    // Exports
	    if (true) {
	        // AMD
	        !(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
	            return Generator;
	        }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	    } else if (typeof module === 'object' && typeof exports === 'object') {
	        // Node/CommonJS
	        module.exports = Generator;
	    } else {
	        // Browser global
	        window.Generator = Generator;
	    }

	}());


/***/ }),
/* 7 */
/***/ (function(module, exports) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	function EventEmitter() {
	  this._events = this._events || {};
	  this._maxListeners = this._maxListeners || undefined;
	}
	module.exports = EventEmitter;

	// Backwards-compat with node 0.10.x
	EventEmitter.EventEmitter = EventEmitter;

	EventEmitter.prototype._events = undefined;
	EventEmitter.prototype._maxListeners = undefined;

	// By default EventEmitters will print a warning if more than 10 listeners are
	// added to it. This is a useful default which helps finding memory leaks.
	EventEmitter.defaultMaxListeners = 10;

	// Obviously not all Emitters should be limited to 10. This function allows
	// that to be increased. Set to zero for unlimited.
	EventEmitter.prototype.setMaxListeners = function(n) {
	  if (!isNumber(n) || n < 0 || isNaN(n))
	    throw TypeError('n must be a positive number');
	  this._maxListeners = n;
	  return this;
	};

	EventEmitter.prototype.emit = function(type) {
	  var er, handler, len, args, i, listeners;

	  if (!this._events)
	    this._events = {};

	  // If there is no 'error' event listener then throw.
	  if (type === 'error') {
	    if (!this._events.error ||
	        (isObject(this._events.error) && !this._events.error.length)) {
	      er = arguments[1];
	      if (er instanceof Error) {
	        throw er; // Unhandled 'error' event
	      }
	      throw TypeError('Uncaught, unspecified "error" event.');
	    }
	  }

	  handler = this._events[type];

	  if (isUndefined(handler))
	    return false;

	  if (isFunction(handler)) {
	    switch (arguments.length) {
	      // fast cases
	      case 1:
	        handler.call(this);
	        break;
	      case 2:
	        handler.call(this, arguments[1]);
	        break;
	      case 3:
	        handler.call(this, arguments[1], arguments[2]);
	        break;
	      // slower
	      default:
	        len = arguments.length;
	        args = new Array(len - 1);
	        for (i = 1; i < len; i++)
	          args[i - 1] = arguments[i];
	        handler.apply(this, args);
	    }
	  } else if (isObject(handler)) {
	    len = arguments.length;
	    args = new Array(len - 1);
	    for (i = 1; i < len; i++)
	      args[i - 1] = arguments[i];

	    listeners = handler.slice();
	    len = listeners.length;
	    for (i = 0; i < len; i++)
	      listeners[i].apply(this, args);
	  }

	  return true;
	};

	EventEmitter.prototype.addListener = function(type, listener) {
	  var m;

	  if (!isFunction(listener))
	    throw TypeError('listener must be a function');

	  if (!this._events)
	    this._events = {};

	  // To avoid recursion in the case that type === "newListener"! Before
	  // adding it to the listeners, first emit "newListener".
	  if (this._events.newListener)
	    this.emit('newListener', type,
	              isFunction(listener.listener) ?
	              listener.listener : listener);

	  if (!this._events[type])
	    // Optimize the case of one listener. Don't need the extra array object.
	    this._events[type] = listener;
	  else if (isObject(this._events[type]))
	    // If we've already got an array, just append.
	    this._events[type].push(listener);
	  else
	    // Adding the second element, need to change to array.
	    this._events[type] = [this._events[type], listener];

	  // Check for listener leak
	  if (isObject(this._events[type]) && !this._events[type].warned) {
	    var m;
	    if (!isUndefined(this._maxListeners)) {
	      m = this._maxListeners;
	    } else {
	      m = EventEmitter.defaultMaxListeners;
	    }

	    if (m && m > 0 && this._events[type].length > m) {
	      this._events[type].warned = true;
	      console.error('(node) warning: possible EventEmitter memory ' +
	                    'leak detected. %d listeners added. ' +
	                    'Use emitter.setMaxListeners() to increase limit.',
	                    this._events[type].length);
	      if (typeof console.trace === 'function') {
	        // not supported in IE 10
	        console.trace();
	      }
	    }
	  }

	  return this;
	};

	EventEmitter.prototype.on = EventEmitter.prototype.addListener;

	EventEmitter.prototype.once = function(type, listener) {
	  if (!isFunction(listener))
	    throw TypeError('listener must be a function');

	  var fired = false;

	  function g() {
	    this.removeListener(type, g);

	    if (!fired) {
	      fired = true;
	      listener.apply(this, arguments);
	    }
	  }

	  g.listener = listener;
	  this.on(type, g);

	  return this;
	};

	// emits a 'removeListener' event iff the listener was removed
	EventEmitter.prototype.removeListener = function(type, listener) {
	  var list, position, length, i;

	  if (!isFunction(listener))
	    throw TypeError('listener must be a function');

	  if (!this._events || !this._events[type])
	    return this;

	  list = this._events[type];
	  length = list.length;
	  position = -1;

	  if (list === listener ||
	      (isFunction(list.listener) && list.listener === listener)) {
	    delete this._events[type];
	    if (this._events.removeListener)
	      this.emit('removeListener', type, listener);

	  } else if (isObject(list)) {
	    for (i = length; i-- > 0;) {
	      if (list[i] === listener ||
	          (list[i].listener && list[i].listener === listener)) {
	        position = i;
	        break;
	      }
	    }

	    if (position < 0)
	      return this;

	    if (list.length === 1) {
	      list.length = 0;
	      delete this._events[type];
	    } else {
	      list.splice(position, 1);
	    }

	    if (this._events.removeListener)
	      this.emit('removeListener', type, listener);
	  }

	  return this;
	};

	EventEmitter.prototype.removeAllListeners = function(type) {
	  var key, listeners;

	  if (!this._events)
	    return this;

	  // not listening for removeListener, no need to emit
	  if (!this._events.removeListener) {
	    if (arguments.length === 0)
	      this._events = {};
	    else if (this._events[type])
	      delete this._events[type];
	    return this;
	  }

	  // emit removeListener for all listeners on all events
	  if (arguments.length === 0) {
	    for (key in this._events) {
	      if (key === 'removeListener') continue;
	      this.removeAllListeners(key);
	    }
	    this.removeAllListeners('removeListener');
	    this._events = {};
	    return this;
	  }

	  listeners = this._events[type];

	  if (isFunction(listeners)) {
	    this.removeListener(type, listeners);
	  } else {
	    // LIFO order
	    while (listeners.length)
	      this.removeListener(type, listeners[listeners.length - 1]);
	  }
	  delete this._events[type];

	  return this;
	};

	EventEmitter.prototype.listeners = function(type) {
	  var ret;
	  if (!this._events || !this._events[type])
	    ret = [];
	  else if (isFunction(this._events[type]))
	    ret = [this._events[type]];
	  else
	    ret = this._events[type].slice();
	  return ret;
	};

	EventEmitter.listenerCount = function(emitter, type) {
	  var ret;
	  if (!emitter._events || !emitter._events[type])
	    ret = 0;
	  else if (isFunction(emitter._events[type]))
	    ret = 1;
	  else
	    ret = emitter._events[type].length;
	  return ret;
	};

	function isFunction(arg) {
	  return typeof arg === 'function';
	}

	function isNumber(arg) {
	  return typeof arg === 'number';
	}

	function isObject(arg) {
	  return typeof arg === 'object' && arg !== null;
	}

	function isUndefined(arg) {
	  return arg === void 0;
	}


/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

	var Bars = __webpack_require__(9),
	    registerBars = __webpack_require__(104),
	    attach = __webpack_require__(105);

	module.exports = function createElement(config, constructor) {
	    var _ = this,
	        bars = new Bars(),
	        el = _.generate(constructor);

	    el.createElement = createElement;
	    el.registerBars = registerBars(bars);
	    el.registerBars(config);
	    el.attach = attach;

	    return el;
	};


/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(10);


/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(11);


/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

	var Bars = __webpack_require__(12),
	    compile = __webpack_require__(79);

	Bars.definePrototype({
	    compile: function compile(template, filename, mode, flags) {
	        var _ = this;
	        return _.build(_.preCompile(template, filename, mode,
	            flags));
	    },

	    preCompile: function preCompile(template, filename, mode, flags) {
	        return compile(template, filename, mode, flags);
	    }
	});

	module.exports = Bars;


/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

	var Generator = __webpack_require__(13),
	    Renderer = __webpack_require__(14),
	    Token = __webpack_require__(55),
	    Blocks = __webpack_require__(77),
	    Transform = __webpack_require__(78),
	    packageJSON = __webpack_require__(63);

	var Bars = Generator.generate(function Bars() {
	    var _ = this;

	    _.defineProperties({
	        blocks: new Blocks(),
	        partials: {},
	        transforms: new Transform()
	    });
	});

	Bars.definePrototype({
	    version: packageJSON.version,
	    build: function build(parsedTemplate, state) {
	        var _ = this,
	            program = parsedTemplate;

	        if (Array.isArray(parsedTemplate)) {
	            program = new Token.tokens.program();

	            program.fromArray(parsedTemplate);
	        }

	        return new Renderer(_, program, state);
	    },

	    registerBlock: function registerBlock(name, block) {
	        var _ = this;

	        _.blocks[name] = block;
	    },

	    registerPartial: function registerPartial(name, compiledTemplate) {
	        var _ = this;

	        if (typeof compiledTemplate === 'string') {
	            if (!_.preCompile) {
	                throw 'partials must be pre-compiled using bars.preCompile(template)';
	            }
	            compiledTemplate = _.preCompile(compiledTemplate, name, null, {
	                minify: true
	            });
	        }

	        var program = compiledTemplate;

	        if (Array.isArray(compiledTemplate)) {
	            program = new Token.tokens.program();

	            program.fromArray(compiledTemplate);
	        }

	        _.partials[name] = program;
	    },

	    registerTransform: function registerTransform(name, func) {
	        var _ = this;

	        _.transforms[name] = func;
	    },
	});

	module.exports = Bars;


/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/**
	 * @name generate.js
	 * @author Michaelangelo Jong
	 */

	(function GeneratorScope() {
	    /**
	     * Assert Error function.
	     * @param  {Boolean} condition Whether or not to throw error.
	     * @param  {String} message    Error message.
	     */
	    function assertError(condition, message) {
	        if (!condition) {
	            throw new Error(message);
	        }
	    }

	    /**
	     * Assert TypeError function.
	     * @param  {Boolean} condition Whether or not to throw error.
	     * @param  {String} message    Error message.
	     */
	    function assertTypeError(test, type) {
	        if (typeof test !== type) {
	            throw new TypeError('Expected \'' + type +
	                '\' but instead found \'' +
	                typeof test + '\'');
	        }
	    }

	    /**
	     * Returns the name of function 'func'.
	     * @param  {Function} func Any function.
	     * @return {String}        Name of 'func'.
	     */
	    function getFunctionName(func) {
	        if (func.name !== void(0)) {
	            return func.name;
	        }
	        // Else use IE Shim
	        var funcNameMatch = func.toString()
	            .match(/function\s*([^\s]*)\s*\(/);
	        func.name = (funcNameMatch && funcNameMatch[1]) || '';
	        return func.name;
	    }

	    /**
	     * Returns true if 'obj' is an object containing only get and set functions, false otherwise.
	     * @param  {Any} obj Value to be tested.
	     * @return {Boolean} true or false.
	     */
	    function isGetSet(obj) {
	        var keys, length;
	        if (obj && typeof obj === 'object') {
	            keys = Object.getOwnPropertyNames(obj)
	                .sort();
	            length = keys.length;

	            if ((length === 1 && (keys[0] === 'get' && typeof obj.get ===
	                    'function' ||
	                    keys[0] === 'set' && typeof obj.set === 'function'
	                )) ||
	                (length === 2 && (keys[0] === 'get' && typeof obj.get ===
	                    'function' &&
	                    keys[1] === 'set' && typeof obj.set === 'function'
	                ))) {
	                return true;
	            }
	        }
	        return false;
	    }

	    /**
	     * Defines properties on 'obj'.
	     * @param  {Object} obj        An object that 'properties' will be attached to.
	     * @param  {Object} descriptor Optional object descriptor that will be applied to all attaching properties on 'properties'.
	     * @param  {Object} properties An object who's properties will be attached to 'obj'.
	     * @return {Generator}         'obj'.
	     */
	    function defineObjectProperties(obj, descriptor, properties) {
	        var setProperties = {},
	            i,
	            keys,
	            length,

	            p = properties || descriptor,
	            d = properties && descriptor;

	        properties = (p && typeof p === 'object') ? p : {};
	        descriptor = (d && typeof d === 'object') ? d : {};

	        keys = Object.getOwnPropertyNames(properties);
	        length = keys.length;

	        for (i = 0; i < length; i++) {
	            if (isGetSet(properties[keys[i]])) {
	                setProperties[keys[i]] = {
	                    configurable: !!descriptor.configurable,
	                    enumerable: !!descriptor.enumerable,
	                    get: properties[keys[i]].get,
	                    set: properties[keys[i]].set
	                };
	            } else {
	                setProperties[keys[i]] = {
	                    configurable: !!descriptor.configurable,
	                    enumerable: !!descriptor.enumerable,
	                    writable: !!descriptor.writable,
	                    value: properties[keys[i]]
	                };
	            }
	        }
	        Object.defineProperties(obj, setProperties);
	        return obj;
	    }



	    var Creation = {
	        /**
	         * Defines properties on this object.
	         * @param  {Object} descriptor Optional object descriptor that will be applied to all attaching properties.
	         * @param  {Object} properties An object who's properties will be attached to this object.
	         * @return {Object}            This object.
	         */
	        defineProperties: function defineProperties(descriptor,
	            properties) {
	            defineObjectProperties(this, descriptor,
	                properties);
	            return this;
	        },

	        /**
	         * returns the prototype of `this` Creation.
	         * @return {Object} Prototype of `this` Creation.
	         */
	        getProto: function getProto() {
	            return Object.getPrototypeOf(this);
	        },

	        /**
	         * returns the prototype of `this` super Creation.
	         * @return {Object} Prototype of `this` super Creation.
	         */
	        getSuper: function getSuper() {
	            return Object.getPrototypeOf(this.constructor.prototype);
	        }
	    };

	    var Generation = {
	        /**
	         * Returns true if 'generator' was generated by this Generator.
	         * @param  {Generator} generator A Generator.
	         * @return {Boolean}             true or false.
	         */
	        isGeneration: function isGeneration(generator) {
	            assertTypeError(generator, 'function');

	            var _ = this;

	            return _.prototype.isPrototypeOf(generator.prototype);
	        },

	        /**
	         * Returns true if 'object' was created by this Generator.
	         * @param  {Object} object An Object.
	         * @return {Boolean}       true or false.
	         */
	        isCreation: function isCreation(object) {
	            var _ = this;
	            return object instanceof _;
	        },
	        /**
	         * Generates a new generator that inherits from `this` generator.
	         * @param {Generator} ParentGenerator Generator to inherit from.
	         * @param {Function} create           Create method that gets called when creating a new instance of new generator.
	         * @return {Generator}                New Generator that inherits from 'ParentGenerator'.
	         */
	        generate: function generate(construct) {
	            assertTypeError(construct, 'function');

	            var _ = this;

	            defineObjectProperties(
	                construct, {
	                    configurable: false,
	                    enumerable: false,
	                    writable: false
	                }, {
	                    prototype: Object.create(_.prototype)
	                }
	            );

	            defineObjectProperties(
	                construct, {
	                    configurable: false,
	                    enumerable: false,
	                    writable: false
	                },
	                Generation
	            );

	            defineObjectProperties(
	                construct.prototype, {
	                    configurable: false,
	                    enumerable: false,
	                    writable: false
	                }, {
	                    constructor: construct,
	                    generator: construct,
	                }
	            );

	            return construct;
	        },

	        /**
	         * Defines shared properties for all objects created by this generator.
	         * @param  {Object} descriptor Optional object descriptor that will be applied to all attaching properties.
	         * @param  {Object} properties An object who's properties will be attached to this generator's prototype.
	         * @return {Generator}         This generator.
	         */
	        definePrototype: function definePrototype(descriptor,
	            properties) {
	            defineObjectProperties(this.prototype,
	                descriptor,
	                properties);
	            return this;
	        }
	    };

	    function Generator() {}

	    defineObjectProperties(
	        Generator, {
	            configurable: false,
	            enumerable: false,
	            writable: false
	        }, {
	            prototype: Generator.prototype
	        }
	    );

	    defineObjectProperties(
	        Generator.prototype, {
	            configurable: false,
	            enumerable: false,
	            writable: false
	        },
	        Creation
	    );

	    defineObjectProperties(
	        Generator, {
	            configurable: false,
	            enumerable: false,
	            writable: false
	        },
	        Generation
	    );

	    defineObjectProperties(
	        Generator, {
	            configurable: false,
	            enumerable: false,
	            writable: false
	        }, {
	            /**
	             * Returns true if 'generator' was generated by this Generator.
	             * @param  {Generator} generator A Generator.
	             * @return {Boolean}             true or false.
	             */
	            isGenerator: function isGenerator(generator) {
	                return this.isGeneration(generator);
	            },

	            /**
	             * Generates a new generator that inherits from `this` generator.
	             * @param {Generator} extendFrom      Constructor to inherit from.
	             * @param {Function} create           Create method that gets called when creating a new instance of new generator.
	             * @return {Generator}                New Generator that inherits from 'ParentGenerator'.
	             */
	            toGenerator: function toGenerator(extendFrom, create) {
	                console.warn(
	                    'Generator.toGenerator is depreciated please use Generator.generateFrom'
	                );
	                return this.generateFrom(extendFrom, create);
	            },

	            /**
	             * Generates a new generator that inherits from `this` generator.
	             * @param {Constructor} extendFrom    Constructor to inherit from.
	             * @param {Function} create           Create method that gets called when creating a new instance of new generator.
	             * @return {Generator}                New Generator that inherits from 'ParentGenerator'.
	             */
	            generateFrom: function generateFrom(extendFrom, create) {
	                assertTypeError(extendFrom, 'function');
	                assertTypeError(create, 'function');

	                defineObjectProperties(
	                    create, {
	                        configurable: false,
	                        enumerable: false,
	                        writable: false
	                    }, {
	                        prototype: Object.create(extendFrom.prototype),
	                    }
	                );

	                defineObjectProperties(
	                    create, {
	                        configurable: false,
	                        enumerable: false,
	                        writable: false
	                    },
	                    Generation
	                );

	                defineObjectProperties(
	                    create.prototype, {
	                        configurable: false,
	                        enumerable: false,
	                        writable: false
	                    }, {
	                        constructor: create,
	                        generator: create,
	                    }
	                );

	                defineObjectProperties(
	                    create.prototype, {
	                        configurable: false,
	                        enumerable: false,
	                        writable: false
	                    },
	                    Creation
	                );

	                return create;
	            }
	        }
	    );

	    Object.freeze(Generator);
	    Object.freeze(Generator.prototype);

	    // Exports
	    if (true) {
	        // AMD
	        !(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
	            return Generator;
	        }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	    } else if (typeof module === 'object' && typeof exports === 'object') {
	        // Node/CommonJS
	        module.exports = Generator;
	    } else {
	        // Browser global
	        window.Generator = Generator;
	    }

	}());


/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

	var Generator = __webpack_require__(13);
	var ContextN = __webpack_require__(15);
	var renderV = __webpack_require__(17);
	var renderT = __webpack_require__(38);

	var diff = __webpack_require__(39);
	var patch = __webpack_require__(45);
	var createElement = __webpack_require__(54);

	function repeat(a, n) {
	    n = n || 0;
	    var r = '';
	    for (var i = 0; i < n; i++) {
	        r += a;
	    }
	    return r;
	}

	var Renderer = Generator.generate(function Renderer(bars, struct, state) {
	    var _ = this;

	    _.bars = bars;
	    _.struct = struct;

	    _.tree = renderV(_.bars, _.struct, new ContextN(state || {}), true);
	    _.rootNode = createElement(_.tree);

	});

	Renderer.definePrototype({
	    update: function update(state) {
	        var _ = this;

	        var newTree = renderV(_.bars, _.struct, new ContextN(state));
	        var patches = diff(_.tree, newTree);
	        patch(_.rootNode, patches);
	        _.tree = newTree;
	    },
	    text: function text(state, options) {
	        var _ = this;

	        options = options || {};

	        var indent = repeat(options.tabs ? '\t' : ' ', options.tabs ? 1 : options.indent);

	        return renderT(_.struct.fragment, indent, _.bars, new ContextN(state));
	    },
	    appendTo: function appendTo(el) {
	        var _ = this;

	        el.appendChild(_.rootNode);
	    }
	});

	module.exports = Renderer;


/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

	var Generator = __webpack_require__(13);
	var utils = __webpack_require__(16);

	var Context = Generator.generate(function Context(data, props, context, cleanVars) {
	    var _ = this;
	  
	    _.data = data;
	    _.props = props;
	    _.context = context;

	    if (cleanVars || !context) {
	        _.vars = Object.create(null);
	    } else {
	        _.vars = Object.create(context.vars);
	    }

	});

	Context.definePrototype({
	    lookup: function lookup(path) {
	        var _ = this,
	            i = 0;

	        if (path[0] === '@') {
	            if (_.props) {
	                return _.props[path[1]];
	            } else {
	                return void(0);
	            }
	        }

	        if (
	            path[0] === 'this'
	        ) {
	            return _.data;
	        }

	        if (_.vars && path[0] in _.vars) {
	            return _.vars[path[0]];
	        }

	        if (_.data === null || _.data === void(0)) {
	            console.warn('Bars Error: Cannot read property ' + path[0] + ' of ' + _.data);
	        }
	      
	        return _.data ? _.data[path[0]] : void(0);
	    },
	    newContext: function newContext(data, props, cleanVars) {
	        return new Context(data, props, this, cleanVars);
	    },
	    contextWithVars: function contextWithVars(vars) {
	        var _ = this;

	        var context = new Context(_.data, _.props, _);

	        context.setVars(vars);

	        return context;
	    },
	    setVars: function setVars(vars) {
	        var _ = this;

	        for (var v in vars) {
	            if (vars.hasOwnProperty(v)) {
	                _.vars[v] = vars[v];
	            }
	        }
	    }
	});

	module.exports = Context;


/***/ }),
/* 16 */
/***/ (function(module, exports) {

	/**
	 * Assert Error function.
	 * @param  {Boolean} condition Whether or not to throw error.
	 * @param  {String} message    Error message.
	 */
	function assertError(condition, message) {
	    if (!condition) {
	        throw new Error(message);
	    }
	}
	exports.assertError = assertError;

	/**
	 * Assert TypeError function.
	 * @param  {Boolean} condition Whether or not to throw error.
	 * @param  {String} message    Error message.
	 */
	function assertTypeError(test, type) {
	    if (typeof test !== type) {
	        throw new TypeError('Expected \'' + type +
	            '\' but instead found \'' +
	            typeof test + '\'');
	    }
	}
	exports.assertTypeError = assertTypeError;

	/**
	 * Repeats a string `n` time.
	 * @param  {String} str String to be repeated.
	 * @param  {Number} n   Number of times to repeat.
	 */
	function repeat(str, n) {
	    var result = '';

	    for (var i = 0; i < n; i++) {
	        result += str;
	    }

	    return result;
	}
	exports.repeat = repeat;

	/**
	 * Returns whatever you pass it.
	 * @param  {Any} a CodeBuffer to slice.
	 */
	function varThrough(a) {
	    return a;
	}
	exports.varThrough = varThrough;

	/**
	 * Stringified CodeBuffer slice.
	 * @param  {CodeBuffer} code CodeBuffer to slice.
	 * @param  {Number} range    Range to slice before and after `code.index`.
	 */
	function bufferSlice(code, range, format) {
	    format = format || varThrough;
	    return JSON.stringify(
	            code.slice(Math.max(0, code.index - range), code.index)
	        )
	        .slice(1, -1) +
	        format(
	            JSON.stringify(code.charAt(code.index) || 'EOF')
	            .slice(1, -1)
	        ) +
	        JSON.stringify(
	            code.slice(
	                code.index + 1,
	                Math.min(code.length, code.index + 1 + range)
	            )
	        )
	        .slice(1, -1);
	}
	exports.bufferSlice = bufferSlice;


/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

	var h = __webpack_require__(18);
	var execute = __webpack_require__(36);

	function makeVars(context, map, bars) {
	    var vars = {};
	    for (var i = 0; i < map.length; i++) {
	        vars[map[i].name] = execute(map[i].expression, bars.transforms, context);
	    }
	    // console.log(vars);
	    return vars;
	}

	function renderTextNode(bars, struct, context) {
	    return struct.value;
	}

	var PROP_MAP = {
	    'class': 'className'
	};

	function renderAttrsAndProps(bars, struct, context) {
	    var i,
	        _data = {},
	        props = {},
	        attrs = {};

	    function get(name) {
	        return _data[name];
	    }

	    props.data = get;

	    for (i = 0; i < struct.attrs.length; i++) {
	        var attr = struct.attrs[i];
	        attrs[attr.name] = renderChildrenTexts(bars, attr, context);
	    }


	    for (i = 0; i < struct.props.length; i++) {
	        _data[struct.props[i].name] = execute(struct.props[i].expression, bars.transforms, context);
	    }

	    props.attributes = attrs;
	    // var key = context.lookup(['@', 'key']);
	    // props.key = /[^0-9]/.test(key) ? key : context.lookup(['id']); What is this supposed to do?

	    return props;
	}

	function renderInsert(bars, struct, context) {
	    return execute(struct.expression, bars.transforms, context);
	}

	function renderChildrenTexts(bars, struct, context) {
	    var children = [];
	    if (!struct || !struct.nodes) return children.join('');
	    for (var i = 0; i < struct.nodes.length; i++) {
	        var child = struct.nodes[i];

	        if (child.type === 'text') {
	            children.push(child.value);
	        } else if (child.type === 'insert') {
	            children.push(renderInsert(bars, child, context));
	        } else if (child.type === 'block') {
	            children.push(renderBlockAsTexts(bars, child, context));
	        }
	    }

	    return children.join('');
	}

	function renderBlockAsTexts(bars, struct, context) {
	    var nodes = [];

	    function consequent(new_context) {
	        new_context = new_context || context;
	        new_context = new_context.contextWithVars(makeVars(new_context, struct.map, bars));
	        nodes.push(renderTypeAsTexts(bars, struct.consequent, new_context));
	    }

	    function alternate(new_context) {
	        if (new_context) {
	            new_context = new_context.contextWithVars(makeVars(new_context, struct.map, bars));
	        }
	        nodes.push(renderTypeAsTexts(bars, struct.alternate, new_context || context));
	    }

	    var blockFunc = bars.blocks[struct.name];

	    if (typeof blockFunc !== 'function') {
	        throw 'Bars Error: Missing Block helper: ' + struct.name;
	    }

	    blockFunc(
	        struct.arguments.map(function (expression) {
	            return execute(expression, bars.transforms, context);
	        }),
	        consequent,
	        alternate,
	        context
	    );

	    return nodes.join('');
	}

	function renderBlockAsNodes(bars, struct, context) {
	    var nodes = [];

	    function consequent(new_context) {
	        new_context = new_context || context;
	        new_context = new_context.contextWithVars(makeVars(new_context, struct.map, bars));
	        nodes = nodes.concat(renderTypeAsNodes(bars, struct.consequent, new_context));
	    }

	    function alternate(new_context) {
	        if (new_context) {
	            new_context = new_context.contextWithVars(makeVars(new_context, struct.map, bars));
	        }
	        nodes = nodes.concat(renderTypeAsNodes(bars, struct.alternate, new_context || context));
	    }

	    var blockFunc = bars.blocks[struct.name];

	    if (typeof blockFunc !== 'function') {
	        throw 'Bars Error: Missing Block helper: ' + struct.name;
	    }

	    blockFunc(
	        struct.arguments.map(function (expression) {
	            return execute(expression, bars.transforms, context);
	        }),
	        consequent,
	        alternate,
	        context
	    );

	    return nodes;
	}

	function renderPartial(bars, struct, context) {
	    var name = struct.name;
	    if (typeof struct.name === 'object') {
	        name = execute(struct.name, bars.transforms, context);
	    }

	    var partial = bars.partials[name];

	    if (!partial) {
	        throw 'Bars Error: Missing Partial: ' + name;
	    }

	    if (struct.expression) {
	        context = context.newContext(
	            execute(struct.expression, bars.transforms, context),
	            null,
	            true
	        );
	    }

	    context = context.contextWithVars(makeVars(context, struct.map, bars));

	    return renderChildrenNodes(bars, partial.fragment, context);
	}

	function renderChildrenNodes(bars, struct, context) {
	    var children = [];
	    if (!struct || !struct.nodes) return children;
	    for (var i = 0; i < struct.nodes.length; i++) {
	        var child = struct.nodes[i];

	        if (child.type === 'tag') {
	            children.push(renderTagNode(bars, child, context));
	        } else if (child.type === 'text') {
	            children.push(renderTextNode(bars, child, context));
	        } else if (child.type === 'insert') {
	            children.push(renderInsert(bars, child, context));
	        } else if (child.type === 'block') {
	            children = children.concat(renderBlockAsNodes(bars, child, context));
	        } else if (child.type === 'partial') {
	            children = children.concat(renderPartial(bars, child, context));
	        }
	    }

	    return children;
	}

	function renderTagNode(bars, struct, context) {
	    return h(
	        struct.name,
	        renderAttrsAndProps(bars, struct, context),
	        renderChildrenNodes(bars, struct, context)
	    );
	}

	function renderTypeAsNodes(bars, struct, context) {
	    if (!struct) return [];
	    if (struct.type === 'tag') {
	        return [renderTagNode(bars, struct, context)];
	    } else if (struct.type === 'text') {
	        return [renderTextNode(bars, struct, context)];
	    } else if (struct.type === 'insert') {
	        return [renderInsert(bars, struct, context)];
	    } else if (struct.type === 'block') {
	        return renderBlockAsNodes(bars, struct, context);
	    } else if (struct.type === 'fragment') {
	        return renderChildrenNodes(bars, struct, context);
	    } else if (struct.type === 'partial') {
	        return renderPartial(bars, struct, context);
	    }

	    throw 'Bars Error: unknown type: ' + struct.type;
	}

	function renderTypeAsTexts(bars, struct, context) {
	    if (!struct) return [];
	    if (struct.type === 'text') {
	        return struct.value;
	    } else if (struct.type === 'insert') {
	        return renderInsert(bars, struct, context);
	    } else if (struct.type === 'block') {
	        return renderBlockAsTexts(bars, struct, context);
	    } else if (struct.type === 'fragment') {
	        return renderChildrenTexts(bars, struct, context);
	    }
	    throw 'Bars Error: unknown type: ' + struct.type;
	}

	function render(bars, struct, context, noRender) {
	    return h(
	        'div',
	        noRender ? [] : renderChildrenNodes(bars, struct.fragment, context)
	    );
	}

	module.exports = render;


/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

	var h = __webpack_require__(19)

	module.exports = h


/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var isArray = __webpack_require__(20);

	var VNode = __webpack_require__(21);
	var VText = __webpack_require__(27);
	var isVNode = __webpack_require__(23);
	var isVText = __webpack_require__(28);
	var isWidget = __webpack_require__(24);
	var isHook = __webpack_require__(26);
	var isVThunk = __webpack_require__(25);

	var parseTag = __webpack_require__(29);
	var softSetHook = __webpack_require__(31);
	var evHook = __webpack_require__(32);

	module.exports = h;

	function h(tagName, properties, children) {
	    var childNodes = [];
	    var tag, props, key, namespace;

	    if (!children && isChildren(properties)) {
	        children = properties;
	        props = {};
	    }

	    props = props || properties || {};
	    tag = parseTag(tagName, props);

	    // support keys
	    if (props.hasOwnProperty('key')) {
	        key = props.key;
	        props.key = undefined;
	    }

	    // support namespace
	    if (props.hasOwnProperty('namespace')) {
	        namespace = props.namespace;
	        props.namespace = undefined;
	    }

	    // fix cursor bug
	    if (tag === 'INPUT' &&
	        !namespace &&
	        props.hasOwnProperty('value') &&
	        props.value !== undefined &&
	        !isHook(props.value)
	    ) {
	        props.value = softSetHook(props.value);
	    }

	    transformProperties(props);

	    if (children !== undefined && children !== null) {
	        addChild(children, childNodes, tag, props);
	    }


	    return new VNode(tag, props, childNodes, key, namespace);
	}

	function addChild(c, childNodes, tag, props) {
	    if (typeof c === 'string') {
	        childNodes.push(new VText(c));
	    } else if (typeof c === 'number') {
	        childNodes.push(new VText(String(c)));
	    } else if (isChild(c)) {
	        childNodes.push(c);
	    } else if (isArray(c)) {
	        for (var i = 0; i < c.length; i++) {
	            addChild(c[i], childNodes, tag, props);
	        }
	    } else if (c === null || c === undefined) {
	        return;
	    } else {
	        throw UnexpectedVirtualElement({
	            foreignObject: c,
	            parentVnode: {
	                tagName: tag,
	                properties: props
	            }
	        });
	    }
	}

	function transformProperties(props) {
	    for (var propName in props) {
	        if (props.hasOwnProperty(propName)) {
	            var value = props[propName];

	            if (isHook(value)) {
	                continue;
	            }

	            if (propName.substr(0, 3) === 'ev-') {
	                // add ev-foo support
	                props[propName] = evHook(value);
	            }
	        }
	    }
	}

	function isChild(x) {
	    return isVNode(x) || isVText(x) || isWidget(x) || isVThunk(x);
	}

	function isChildren(x) {
	    return typeof x === 'string' || isArray(x) || isChild(x);
	}

	function UnexpectedVirtualElement(data) {
	    var err = new Error();

	    err.type = 'virtual-hyperscript.unexpected.virtual-element';
	    err.message = 'Unexpected virtual child passed to h().\n' +
	        'Expected a VNode / Vthunk / VWidget / string but:\n' +
	        'got:\n' +
	        errorString(data.foreignObject) +
	        '.\n' +
	        'The parent vnode is:\n' +
	        errorString(data.parentVnode)
	        '\n' +
	        'Suggested fix: change your `h(..., [ ... ])` callsite.';
	    err.foreignObject = data.foreignObject;
	    err.parentVnode = data.parentVnode;

	    return err;
	}

	function errorString(obj) {
	    try {
	        return JSON.stringify(obj, null, '    ');
	    } catch (e) {
	        return String(obj);
	    }
	}


/***/ }),
/* 20 */
/***/ (function(module, exports) {

	var nativeIsArray = Array.isArray
	var toString = Object.prototype.toString

	module.exports = nativeIsArray || isArray

	function isArray(obj) {
	    return toString.call(obj) === "[object Array]"
	}


/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

	var version = __webpack_require__(22)
	var isVNode = __webpack_require__(23)
	var isWidget = __webpack_require__(24)
	var isThunk = __webpack_require__(25)
	var isVHook = __webpack_require__(26)

	module.exports = VirtualNode

	var noProperties = {}
	var noChildren = []

	function VirtualNode(tagName, properties, children, key, namespace) {
	    this.tagName = tagName
	    this.properties = properties || noProperties
	    this.children = children || noChildren
	    this.key = key != null ? String(key) : undefined
	    this.namespace = (typeof namespace === "string") ? namespace : null

	    var count = (children && children.length) || 0
	    var descendants = 0
	    var hasWidgets = false
	    var hasThunks = false
	    var descendantHooks = false
	    var hooks

	    for (var propName in properties) {
	        if (properties.hasOwnProperty(propName)) {
	            var property = properties[propName]
	            if (isVHook(property) && property.unhook) {
	                if (!hooks) {
	                    hooks = {}
	                }

	                hooks[propName] = property
	            }
	        }
	    }

	    for (var i = 0; i < count; i++) {
	        var child = children[i]
	        if (isVNode(child)) {
	            descendants += child.count || 0

	            if (!hasWidgets && child.hasWidgets) {
	                hasWidgets = true
	            }

	            if (!hasThunks && child.hasThunks) {
	                hasThunks = true
	            }

	            if (!descendantHooks && (child.hooks || child.descendantHooks)) {
	                descendantHooks = true
	            }
	        } else if (!hasWidgets && isWidget(child)) {
	            if (typeof child.destroy === "function") {
	                hasWidgets = true
	            }
	        } else if (!hasThunks && isThunk(child)) {
	            hasThunks = true;
	        }
	    }

	    this.count = count + descendants
	    this.hasWidgets = hasWidgets
	    this.hasThunks = hasThunks
	    this.hooks = hooks
	    this.descendantHooks = descendantHooks
	}

	VirtualNode.prototype.version = version
	VirtualNode.prototype.type = "VirtualNode"


/***/ }),
/* 22 */
/***/ (function(module, exports) {

	module.exports = "2"


/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

	var version = __webpack_require__(22)

	module.exports = isVirtualNode

	function isVirtualNode(x) {
	    return x && x.type === "VirtualNode" && x.version === version
	}


/***/ }),
/* 24 */
/***/ (function(module, exports) {

	module.exports = isWidget

	function isWidget(w) {
	    return w && w.type === "Widget"
	}


/***/ }),
/* 25 */
/***/ (function(module, exports) {

	module.exports = isThunk

	function isThunk(t) {
	    return t && t.type === "Thunk"
	}


/***/ }),
/* 26 */
/***/ (function(module, exports) {

	module.exports = isHook

	function isHook(hook) {
	    return hook &&
	      (typeof hook.hook === "function" && !hook.hasOwnProperty("hook") ||
	       typeof hook.unhook === "function" && !hook.hasOwnProperty("unhook"))
	}


/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

	var version = __webpack_require__(22)

	module.exports = VirtualText

	function VirtualText(text) {
	    this.text = String(text)
	}

	VirtualText.prototype.version = version
	VirtualText.prototype.type = "VirtualText"


/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

	var version = __webpack_require__(22)

	module.exports = isVirtualText

	function isVirtualText(x) {
	    return x && x.type === "VirtualText" && x.version === version
	}


/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var split = __webpack_require__(30);

	var classIdSplit = /([\.#]?[a-zA-Z0-9\u007F-\uFFFF_:-]+)/;
	var notClassId = /^\.|#/;

	module.exports = parseTag;

	function parseTag(tag, props) {
	    if (!tag) {
	        return 'DIV';
	    }

	    var noId = !(props.hasOwnProperty('id'));

	    var tagParts = split(tag, classIdSplit);
	    var tagName = null;

	    if (notClassId.test(tagParts[1])) {
	        tagName = 'DIV';
	    }

	    var classes, part, type, i;

	    for (i = 0; i < tagParts.length; i++) {
	        part = tagParts[i];

	        if (!part) {
	            continue;
	        }

	        type = part.charAt(0);

	        if (!tagName) {
	            tagName = part;
	        } else if (type === '.') {
	            classes = classes || [];
	            classes.push(part.substring(1, part.length));
	        } else if (type === '#' && noId) {
	            props.id = part.substring(1, part.length);
	        }
	    }

	    if (classes) {
	        if (props.className) {
	            classes.push(props.className);
	        }

	        props.className = classes.join(' ');
	    }

	    return props.namespace ? tagName : tagName.toUpperCase();
	}


/***/ }),
/* 30 */
/***/ (function(module, exports) {

	/*!
	 * Cross-Browser Split 1.1.1
	 * Copyright 2007-2012 Steven Levithan <stevenlevithan.com>
	 * Available under the MIT License
	 * ECMAScript compliant, uniform cross-browser split method
	 */

	/**
	 * Splits a string into an array of strings using a regex or string separator. Matches of the
	 * separator are not included in the result array. However, if `separator` is a regex that contains
	 * capturing groups, backreferences are spliced into the result each time `separator` is matched.
	 * Fixes browser bugs compared to the native `String.prototype.split` and can be used reliably
	 * cross-browser.
	 * @param {String} str String to split.
	 * @param {RegExp|String} separator Regex or string to use for separating the string.
	 * @param {Number} [limit] Maximum number of items to include in the result array.
	 * @returns {Array} Array of substrings.
	 * @example
	 *
	 * // Basic use
	 * split('a b c d', ' ');
	 * // -> ['a', 'b', 'c', 'd']
	 *
	 * // With limit
	 * split('a b c d', ' ', 2);
	 * // -> ['a', 'b']
	 *
	 * // Backreferences in result array
	 * split('..word1 word2..', /([a-z]+)(\d+)/i);
	 * // -> ['..', 'word', '1', ' ', 'word', '2', '..']
	 */
	module.exports = (function split(undef) {

	  var nativeSplit = String.prototype.split,
	    compliantExecNpcg = /()??/.exec("")[1] === undef,
	    // NPCG: nonparticipating capturing group
	    self;

	  self = function(str, separator, limit) {
	    // If `separator` is not a regex, use `nativeSplit`
	    if (Object.prototype.toString.call(separator) !== "[object RegExp]") {
	      return nativeSplit.call(str, separator, limit);
	    }
	    var output = [],
	      flags = (separator.ignoreCase ? "i" : "") + (separator.multiline ? "m" : "") + (separator.extended ? "x" : "") + // Proposed for ES6
	      (separator.sticky ? "y" : ""),
	      // Firefox 3+
	      lastLastIndex = 0,
	      // Make `global` and avoid `lastIndex` issues by working with a copy
	      separator = new RegExp(separator.source, flags + "g"),
	      separator2, match, lastIndex, lastLength;
	    str += ""; // Type-convert
	    if (!compliantExecNpcg) {
	      // Doesn't need flags gy, but they don't hurt
	      separator2 = new RegExp("^" + separator.source + "$(?!\\s)", flags);
	    }
	    /* Values for `limit`, per the spec:
	     * If undefined: 4294967295 // Math.pow(2, 32) - 1
	     * If 0, Infinity, or NaN: 0
	     * If positive number: limit = Math.floor(limit); if (limit > 4294967295) limit -= 4294967296;
	     * If negative number: 4294967296 - Math.floor(Math.abs(limit))
	     * If other: Type-convert, then use the above rules
	     */
	    limit = limit === undef ? -1 >>> 0 : // Math.pow(2, 32) - 1
	    limit >>> 0; // ToUint32(limit)
	    while (match = separator.exec(str)) {
	      // `separator.lastIndex` is not reliable cross-browser
	      lastIndex = match.index + match[0].length;
	      if (lastIndex > lastLastIndex) {
	        output.push(str.slice(lastLastIndex, match.index));
	        // Fix browsers whose `exec` methods don't consistently return `undefined` for
	        // nonparticipating capturing groups
	        if (!compliantExecNpcg && match.length > 1) {
	          match[0].replace(separator2, function() {
	            for (var i = 1; i < arguments.length - 2; i++) {
	              if (arguments[i] === undef) {
	                match[i] = undef;
	              }
	            }
	          });
	        }
	        if (match.length > 1 && match.index < str.length) {
	          Array.prototype.push.apply(output, match.slice(1));
	        }
	        lastLength = match[0].length;
	        lastLastIndex = lastIndex;
	        if (output.length >= limit) {
	          break;
	        }
	      }
	      if (separator.lastIndex === match.index) {
	        separator.lastIndex++; // Avoid an infinite loop
	      }
	    }
	    if (lastLastIndex === str.length) {
	      if (lastLength || !separator.test("")) {
	        output.push("");
	      }
	    } else {
	      output.push(str.slice(lastLastIndex));
	    }
	    return output.length > limit ? output.slice(0, limit) : output;
	  };

	  return self;
	})();


/***/ }),
/* 31 */
/***/ (function(module, exports) {

	'use strict';

	module.exports = SoftSetHook;

	function SoftSetHook(value) {
	    if (!(this instanceof SoftSetHook)) {
	        return new SoftSetHook(value);
	    }

	    this.value = value;
	}

	SoftSetHook.prototype.hook = function (node, propertyName) {
	    if (node[propertyName] !== this.value) {
	        node[propertyName] = this.value;
	    }
	};


/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var EvStore = __webpack_require__(33);

	module.exports = EvHook;

	function EvHook(value) {
	    if (!(this instanceof EvHook)) {
	        return new EvHook(value);
	    }

	    this.value = value;
	}

	EvHook.prototype.hook = function (node, propertyName) {
	    var es = EvStore(node);
	    var propName = propertyName.substr(3);

	    es[propName] = this.value;
	};

	EvHook.prototype.unhook = function(node, propertyName) {
	    var es = EvStore(node);
	    var propName = propertyName.substr(3);

	    es[propName] = undefined;
	};


/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var OneVersionConstraint = __webpack_require__(34);

	var MY_VERSION = '7';
	OneVersionConstraint('ev-store', MY_VERSION);

	var hashKey = '__EV_STORE_KEY@' + MY_VERSION;

	module.exports = EvStore;

	function EvStore(elem) {
	    var hash = elem[hashKey];

	    if (!hash) {
	        hash = elem[hashKey] = {};
	    }

	    return hash;
	}


/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var Individual = __webpack_require__(35);

	module.exports = OneVersion;

	function OneVersion(moduleName, version, defaultValue) {
	    var key = '__INDIVIDUAL_ONE_VERSION_' + moduleName;
	    var enforceKey = key + '_ENFORCE_SINGLETON';

	    var versionValue = Individual(enforceKey, version);

	    if (versionValue !== version) {
	        throw new Error('Can only have one copy of ' +
	            moduleName + '.\n' +
	            'You already have version ' + versionValue +
	            ' installed.\n' +
	            'This means you cannot install version ' + version);
	    }

	    return Individual(key, defaultValue);
	}


/***/ }),
/* 35 */
/***/ (function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(global) {'use strict';

	/*global window, global*/

	var root = typeof window !== 'undefined' ?
	    window : typeof global !== 'undefined' ?
	    global : {};

	module.exports = Individual;

	function Individual(key, value) {
	    if (key in root) {
	        return root[key];
	    }

	    root[key] = value;

	    return value;
	}

	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

	var logic = __webpack_require__(37);

	function execute(syntaxTree, transforms, context) {
	    function run(token) {
	        var result,
	            args = [];
	        // token.type === 'operator' ? console.log('>>>>', token) : void(0);
	        if (
	            token.type === 'literal'
	        ) {
	            result = token.value;
	        } else if (
	            token.type === 'value'
	        ) {
	            result = context.lookup(token.path);
	        } else if (
	            token.type === 'operator' &&
	            token.operands.length === 1
	        ) {
	            result = logic[token.operator](
	                run(token.operands[0])
	            );
	        } else if (
	            token.type === 'operator' &&
	            token.operator === '?:'
	        ) {
	            result = run(token.operands[0]) ?
	                run(token.operands[1]) :
	                run(token.operands[2]);
	        } else if (
	            token.type === 'operator' &&
	            token.operands.length === 2
	        ) {
	            if (token.operator === '||') {
	                result = run(token.operands[0]) || run(token.operands[1]);
	            } else if (token.operator === '&&') {
	                result = run(token.operands[0]) && run(token.operands[1]);
	            } else {
	                result = logic[token.operator](
	                    run(token.operands[0]),
	                    run(token.operands[1])
	                );
	            }
	        } else if (
	            token.type === 'transform'
	        ) {
	            for (var i = 0; i < token.arguments.length; i++) {
	                args.push(run(token.arguments[i]));
	            }
	            if (transforms[token.name] instanceof Function) {
	                result = transforms[token.name].apply(null, args);
	            } else {
	                throw 'Bars Error: Missing Transfrom: "' + token.name + '".';
	            }
	        }
	        // console.log('<<<<', result)
	        return result;
	    }

	    if (syntaxTree) {
	        return run(syntaxTree);
	    } else {
	        return context.lookup('this');
	    }
	}

	module.exports = execute;


/***/ }),
/* 37 */
/***/ (function(module, exports) {

	/*Look up*/
	exports.lookup = function add(a, b) {

	    if (a === null || a === void(0)) {
	        console.warn('Bars Error: Cannot read property ' + b + ' of ' + a);
	    }
	    return a ? a[b] : void(0); // soft
	    // return a[b]; // hard
	};
	exports['.'] = exports.lookup;

	/* Arithmetic */
	exports.add = function add(a, b) {
	    return a + b;
	};
	exports.subtract = function subtract(a, b) {
	    return a - b;
	};
	exports.multiply = function multiply(a, b) {
	    return a * b;
	};
	exports.devide = function devide(a, b) {
	    return a / b;
	};
	exports.mod = function mod(a, b) {
	    return a % b;
	};

	exports['+'] = exports.add;
	exports['-'] = exports.subtract;
	exports['*'] = exports.multiply;
	exports['/'] = exports.devide;
	exports['%'] = exports.mod;

	/* Logic */

	exports.not = function not(a) {
	    return !a;
	};

	exports['!'] = exports.not;

	exports.or = function or(a, b) {
	    return a || b;
	};
	exports.and = function and(a, b) {
	    return a && b;
	};

	exports['||'] = exports.or;
	exports['&&'] = exports.and;

	/* Comparison */

	exports.strictequals = function strictequals(a, b) {
	    return a === b;
	};
	exports.strictnotequals = function strictnotequals(a, b) {
	    return a !== b;
	};

	exports['==='] = exports.strictequals;
	exports['!=='] = exports.strictnotequals;

	exports.equals = function equals(a, b) {
	    return a == b;
	};
	exports.notequals = function notequals(a, b) {
	    return a != b;
	};
	exports.ltequals = function ltequals(a, b) {
	    return a <= b;
	};
	exports.gtequals = function gtequals(a, b) {
	    return a >= b;
	};

	exports['=='] = exports.equals;
	exports['!='] = exports.notequals;
	exports['<='] = exports.ltequals;
	exports['>='] = exports.gtequals;

	exports.lt = function lt(a, b) {
	    return a < b;
	};
	exports.gt = function gt(a, b) {
	    return a > b;
	};

	exports['<'] = exports.lt;
	exports['>'] = exports.gt;


/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

	var execute = __webpack_require__(36);

	function makeVars(context, map, bars) {
	    var vars = {};
	    for (var i = 0; i < map.length; i++) {
	        vars[map[i].name] = execute(map[i].expression, bars.transforms, context);
	    }
	    // console.log(vars);
	    return vars;
	}

	function repeat(a, n) {
	    n = n || 0;
	    var r = '';
	    for (var i = 0; i < n; i++) {
	        r += a;
	    }
	    return r;
	}

	function abb(token, indentWith, bars, context) {
	    var r = '';

	    function consequent(new_context) {
	        new_context = new_context || context;
	        new_context = new_context.contextWithVars(makeVars(new_context, token.map, bars));
	        r += ac(token.consequent.nodes, indentWith, bars, new_context);
	    }

	    function alternate(new_context) {
	        if (new_context) {
	            new_context = new_context.contextWithVars(makeVars(new_context, token.map, bars));
	        }
	        r += ac(token.alternate.nodes, indentWith, bars, new_context || context);
	    }

	    var blockFunc = bars.blocks[token.name];

	    if (typeof blockFunc !== 'function') {
	        throw 'Bars Error: Missing Block helper: ' + token.name;
	    }

	    blockFunc(
	        token.arguments.map(function (expression) {
	            return execute(expression, bars.transforms, context);
	        }),
	        consequent,
	        alternate,
	        context
	    );

	    return r;
	}

	function ac(tokens, indentWith, bars, context) {
	    if (tokens.length === 0) {
	        return '';
	    }

	    var r = '="';

	    for (var i = 0; i < tokens.length; i++) {
	        var token = tokens[i];
	        if (token.type === 'text') {
	            r += token.value;
	        } else if (token.type === 'insert') {
	            var val = execute(token.expression, bars.transforms, context);
	            r += val !== void(0) ? val : '';
	        } else if (token.type === 'block') {
	            r += abb(token, indentWith, bars, context);
	        }
	    }

	    r += '"';

	    return r;
	}

	function a(token, indentWith, bars, context) {
	    var r = ' ';
	    r += token.name;
	    r += ac(token.nodes, indentWith, bars, context);

	    return r;
	}

	function hbb(token, indentWith, indent, bars, context) {
	    var r = '';

	    function consequent(new_context) {
	        new_context = new_context || context;
	        new_context = new_context.contextWithVars(makeVars(new_context, token.map, bars));
	        r += hc(token.consequent.nodes, indentWith, indent, bars, new_context);
	    }

	    function alternate(new_context) {
	        if (new_context) {
	            new_context = new_context.contextWithVars(makeVars(new_context, token.map, bars));
	        }
	        r += hc(token.alternate.nodes, indentWith, indent, bars, new_context || context);
	    }

	    var blockFunc = bars.blocks[token.name];

	    if (typeof blockFunc !== 'function') {
	        throw 'Bars Error: Missing Block helper: ' + token.name;
	    }

	    blockFunc(
	        token.arguments.map(function (expression) {
	            return execute(expression, bars.transforms, context);
	        }),
	        consequent,
	        alternate,
	        context
	    );

	    return r;
	}

	function hbp(token, indentWith, indent, bars, context) {
	    var name = token.name;
	    if (typeof token.name === 'object') {
	        name = execute(token.name, bars.transforms, context);
	    }

	    var partial = bars.partials[name];

	    if (!partial) {
	        throw 'Bars Error: Missing Partial: ' + name;
	    }

	    if (token.expression) {
	        context = context.newContext(
	            execute(token.expression, bars.transforms, context),
	            null,
	            true
	        );
	    }

	    context = context.contextWithVars(makeVars(context, token.map, bars));

	    return hc(partial.fragment.nodes, indentWith, indent, bars, context);
	}

	function hc(tokens, indentWith, indent, bars, context) {
	    if (tokens.length === 0) {
	        return '';
	    }
	    var val;
	    if (tokens.length === 1) {
	        if (tokens[0].type === 'text') {
	            return tokens[0].value;
	        } else if (tokens[0].type === 'insert') {
	            val = execute(tokens[0].expression, bars.transforms, context);
	            return val !== void(0) ? val : '';
	        }
	    }

	    var r = '\n';

	    for (var i = 0; i < tokens.length; i++) {
	        var token = tokens[i];
	        r += repeat(indentWith, indent + 1);
	        if (token.type === 'tag') {
	            r += h(token, indentWith, indent + 1, bars, context);
	        } else if (token.type === 'text') {
	            r += token.value;
	        } else if (token.type === 'insert') {
	            val = execute(token.expression, bars.transforms, context);
	            r += val !== void(0) ? val : '';
	        } else if (token.type === 'block') {
	            r += hbb(token, indentWith, indent, bars, context);
	        } else if (token.type === 'partial') {
	            r += hbp(token, indentWith, indent, bars, context);
	        }
	    }

	    r += repeat(indentWith, indent);

	    return r;
	}

	function h(token, indentWith, indent, bars, context) {
	    var r = '';

	    r += '<' + token.name;

	    for (var i = 0; i < token.attrs.length; i++) {
	        r += a(token.attrs[i], indentWith, bars, context);
	    }

	    if (token.isSelfClosing || token.selfClosed) {
	        r += ' />';
	    } else {
	        r += '>';

	        r += hc(token.nodes, indentWith, indent, bars, context);

	        r += '</' + token.name + '>';
	    }

	    r += '\n';

	    return r;
	}

	function render(fragment, indentWith, bars, context) {
	    return hc(fragment.nodes, indentWith, -1, bars, context);
	}

	module.exports = render;


/***/ }),
/* 39 */
/***/ (function(module, exports, __webpack_require__) {

	var diff = __webpack_require__(40)

	module.exports = diff


/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

	var isArray = __webpack_require__(20)

	var VPatch = __webpack_require__(41)
	var isVNode = __webpack_require__(23)
	var isVText = __webpack_require__(28)
	var isWidget = __webpack_require__(24)
	var isThunk = __webpack_require__(25)
	var handleThunk = __webpack_require__(42)

	var diffProps = __webpack_require__(43)

	module.exports = diff

	function diff(a, b) {
	    var patch = { a: a }
	    walk(a, b, patch, 0)
	    return patch
	}

	function walk(a, b, patch, index) {
	    if (a === b) {
	        return
	    }

	    var apply = patch[index]
	    var applyClear = false

	    if (isThunk(a) || isThunk(b)) {
	        thunks(a, b, patch, index)
	    } else if (b == null) {

	        // If a is a widget we will add a remove patch for it
	        // Otherwise any child widgets/hooks must be destroyed.
	        // This prevents adding two remove patches for a widget.
	        if (!isWidget(a)) {
	            clearState(a, patch, index)
	            apply = patch[index]
	        }

	        apply = appendPatch(apply, new VPatch(VPatch.REMOVE, a, b))
	    } else if (isVNode(b)) {
	        if (isVNode(a)) {
	            if (a.tagName === b.tagName &&
	                a.namespace === b.namespace &&
	                a.key === b.key) {
	                var propsPatch = diffProps(a.properties, b.properties)
	                if (propsPatch) {
	                    apply = appendPatch(apply,
	                        new VPatch(VPatch.PROPS, a, propsPatch))
	                }
	                apply = diffChildren(a, b, patch, apply, index)
	            } else {
	                apply = appendPatch(apply, new VPatch(VPatch.VNODE, a, b))
	                applyClear = true
	            }
	        } else {
	            apply = appendPatch(apply, new VPatch(VPatch.VNODE, a, b))
	            applyClear = true
	        }
	    } else if (isVText(b)) {
	        if (!isVText(a)) {
	            apply = appendPatch(apply, new VPatch(VPatch.VTEXT, a, b))
	            applyClear = true
	        } else if (a.text !== b.text) {
	            apply = appendPatch(apply, new VPatch(VPatch.VTEXT, a, b))
	        }
	    } else if (isWidget(b)) {
	        if (!isWidget(a)) {
	            applyClear = true
	        }

	        apply = appendPatch(apply, new VPatch(VPatch.WIDGET, a, b))
	    }

	    if (apply) {
	        patch[index] = apply
	    }

	    if (applyClear) {
	        clearState(a, patch, index)
	    }
	}

	function diffChildren(a, b, patch, apply, index) {
	    var aChildren = a.children
	    var orderedSet = reorder(aChildren, b.children)
	    var bChildren = orderedSet.children

	    var aLen = aChildren.length
	    var bLen = bChildren.length
	    var len = aLen > bLen ? aLen : bLen

	    for (var i = 0; i < len; i++) {
	        var leftNode = aChildren[i]
	        var rightNode = bChildren[i]
	        index += 1

	        if (!leftNode) {
	            if (rightNode) {
	                // Excess nodes in b need to be added
	                apply = appendPatch(apply,
	                    new VPatch(VPatch.INSERT, null, rightNode))
	            }
	        } else {
	            walk(leftNode, rightNode, patch, index)
	        }

	        if (isVNode(leftNode) && leftNode.count) {
	            index += leftNode.count
	        }
	    }

	    if (orderedSet.moves) {
	        // Reorder nodes last
	        apply = appendPatch(apply, new VPatch(
	            VPatch.ORDER,
	            a,
	            orderedSet.moves
	        ))
	    }

	    return apply
	}

	function clearState(vNode, patch, index) {
	    // TODO: Make this a single walk, not two
	    unhook(vNode, patch, index)
	    destroyWidgets(vNode, patch, index)
	}

	// Patch records for all destroyed widgets must be added because we need
	// a DOM node reference for the destroy function
	function destroyWidgets(vNode, patch, index) {
	    if (isWidget(vNode)) {
	        if (typeof vNode.destroy === "function") {
	            patch[index] = appendPatch(
	                patch[index],
	                new VPatch(VPatch.REMOVE, vNode, null)
	            )
	        }
	    } else if (isVNode(vNode) && (vNode.hasWidgets || vNode.hasThunks)) {
	        var children = vNode.children
	        var len = children.length
	        for (var i = 0; i < len; i++) {
	            var child = children[i]
	            index += 1

	            destroyWidgets(child, patch, index)

	            if (isVNode(child) && child.count) {
	                index += child.count
	            }
	        }
	    } else if (isThunk(vNode)) {
	        thunks(vNode, null, patch, index)
	    }
	}

	// Create a sub-patch for thunks
	function thunks(a, b, patch, index) {
	    var nodes = handleThunk(a, b)
	    var thunkPatch = diff(nodes.a, nodes.b)
	    if (hasPatches(thunkPatch)) {
	        patch[index] = new VPatch(VPatch.THUNK, null, thunkPatch)
	    }
	}

	function hasPatches(patch) {
	    for (var index in patch) {
	        if (index !== "a") {
	            return true
	        }
	    }

	    return false
	}

	// Execute hooks when two nodes are identical
	function unhook(vNode, patch, index) {
	    if (isVNode(vNode)) {
	        if (vNode.hooks) {
	            patch[index] = appendPatch(
	                patch[index],
	                new VPatch(
	                    VPatch.PROPS,
	                    vNode,
	                    undefinedKeys(vNode.hooks)
	                )
	            )
	        }

	        if (vNode.descendantHooks || vNode.hasThunks) {
	            var children = vNode.children
	            var len = children.length
	            for (var i = 0; i < len; i++) {
	                var child = children[i]
	                index += 1

	                unhook(child, patch, index)

	                if (isVNode(child) && child.count) {
	                    index += child.count
	                }
	            }
	        }
	    } else if (isThunk(vNode)) {
	        thunks(vNode, null, patch, index)
	    }
	}

	function undefinedKeys(obj) {
	    var result = {}

	    for (var key in obj) {
	        result[key] = undefined
	    }

	    return result
	}

	// List diff, naive left to right reordering
	function reorder(aChildren, bChildren) {
	    // O(M) time, O(M) memory
	    var bChildIndex = keyIndex(bChildren)
	    var bKeys = bChildIndex.keys
	    var bFree = bChildIndex.free

	    if (bFree.length === bChildren.length) {
	        return {
	            children: bChildren,
	            moves: null
	        }
	    }

	    // O(N) time, O(N) memory
	    var aChildIndex = keyIndex(aChildren)
	    var aKeys = aChildIndex.keys
	    var aFree = aChildIndex.free

	    if (aFree.length === aChildren.length) {
	        return {
	            children: bChildren,
	            moves: null
	        }
	    }

	    // O(MAX(N, M)) memory
	    var newChildren = []

	    var freeIndex = 0
	    var freeCount = bFree.length
	    var deletedItems = 0

	    // Iterate through a and match a node in b
	    // O(N) time,
	    for (var i = 0 ; i < aChildren.length; i++) {
	        var aItem = aChildren[i]
	        var itemIndex

	        if (aItem.key) {
	            if (bKeys.hasOwnProperty(aItem.key)) {
	                // Match up the old keys
	                itemIndex = bKeys[aItem.key]
	                newChildren.push(bChildren[itemIndex])

	            } else {
	                // Remove old keyed items
	                itemIndex = i - deletedItems++
	                newChildren.push(null)
	            }
	        } else {
	            // Match the item in a with the next free item in b
	            if (freeIndex < freeCount) {
	                itemIndex = bFree[freeIndex++]
	                newChildren.push(bChildren[itemIndex])
	            } else {
	                // There are no free items in b to match with
	                // the free items in a, so the extra free nodes
	                // are deleted.
	                itemIndex = i - deletedItems++
	                newChildren.push(null)
	            }
	        }
	    }

	    var lastFreeIndex = freeIndex >= bFree.length ?
	        bChildren.length :
	        bFree[freeIndex]

	    // Iterate through b and append any new keys
	    // O(M) time
	    for (var j = 0; j < bChildren.length; j++) {
	        var newItem = bChildren[j]

	        if (newItem.key) {
	            if (!aKeys.hasOwnProperty(newItem.key)) {
	                // Add any new keyed items
	                // We are adding new items to the end and then sorting them
	                // in place. In future we should insert new items in place.
	                newChildren.push(newItem)
	            }
	        } else if (j >= lastFreeIndex) {
	            // Add any leftover non-keyed items
	            newChildren.push(newItem)
	        }
	    }

	    var simulate = newChildren.slice()
	    var simulateIndex = 0
	    var removes = []
	    var inserts = []
	    var simulateItem

	    for (var k = 0; k < bChildren.length;) {
	        var wantedItem = bChildren[k]
	        simulateItem = simulate[simulateIndex]

	        // remove items
	        while (simulateItem === null && simulate.length) {
	            removes.push(remove(simulate, simulateIndex, null))
	            simulateItem = simulate[simulateIndex]
	        }

	        if (!simulateItem || simulateItem.key !== wantedItem.key) {
	            // if we need a key in this position...
	            if (wantedItem.key) {
	                if (simulateItem && simulateItem.key) {
	                    // if an insert doesn't put this key in place, it needs to move
	                    if (bKeys[simulateItem.key] !== k + 1) {
	                        removes.push(remove(simulate, simulateIndex, simulateItem.key))
	                        simulateItem = simulate[simulateIndex]
	                        // if the remove didn't put the wanted item in place, we need to insert it
	                        if (!simulateItem || simulateItem.key !== wantedItem.key) {
	                            inserts.push({key: wantedItem.key, to: k})
	                        }
	                        // items are matching, so skip ahead
	                        else {
	                            simulateIndex++
	                        }
	                    }
	                    else {
	                        inserts.push({key: wantedItem.key, to: k})
	                    }
	                }
	                else {
	                    inserts.push({key: wantedItem.key, to: k})
	                }
	                k++
	            }
	            // a key in simulate has no matching wanted key, remove it
	            else if (simulateItem && simulateItem.key) {
	                removes.push(remove(simulate, simulateIndex, simulateItem.key))
	            }
	        }
	        else {
	            simulateIndex++
	            k++
	        }
	    }

	    // remove all the remaining nodes from simulate
	    while(simulateIndex < simulate.length) {
	        simulateItem = simulate[simulateIndex]
	        removes.push(remove(simulate, simulateIndex, simulateItem && simulateItem.key))
	    }

	    // If the only moves we have are deletes then we can just
	    // let the delete patch remove these items.
	    if (removes.length === deletedItems && !inserts.length) {
	        return {
	            children: newChildren,
	            moves: null
	        }
	    }

	    return {
	        children: newChildren,
	        moves: {
	            removes: removes,
	            inserts: inserts
	        }
	    }
	}

	function remove(arr, index, key) {
	    arr.splice(index, 1)

	    return {
	        from: index,
	        key: key
	    }
	}

	function keyIndex(children) {
	    var keys = {}
	    var free = []
	    var length = children.length

	    for (var i = 0; i < length; i++) {
	        var child = children[i]

	        if (child.key) {
	            keys[child.key] = i
	        } else {
	            free.push(i)
	        }
	    }

	    return {
	        keys: keys,     // A hash of key name to index
	        free: free      // An array of unkeyed item indices
	    }
	}

	function appendPatch(apply, patch) {
	    if (apply) {
	        if (isArray(apply)) {
	            apply.push(patch)
	        } else {
	            apply = [apply, patch]
	        }

	        return apply
	    } else {
	        return patch
	    }
	}


/***/ }),
/* 41 */
/***/ (function(module, exports, __webpack_require__) {

	var version = __webpack_require__(22)

	VirtualPatch.NONE = 0
	VirtualPatch.VTEXT = 1
	VirtualPatch.VNODE = 2
	VirtualPatch.WIDGET = 3
	VirtualPatch.PROPS = 4
	VirtualPatch.ORDER = 5
	VirtualPatch.INSERT = 6
	VirtualPatch.REMOVE = 7
	VirtualPatch.THUNK = 8

	module.exports = VirtualPatch

	function VirtualPatch(type, vNode, patch) {
	    this.type = Number(type)
	    this.vNode = vNode
	    this.patch = patch
	}

	VirtualPatch.prototype.version = version
	VirtualPatch.prototype.type = "VirtualPatch"


/***/ }),
/* 42 */
/***/ (function(module, exports, __webpack_require__) {

	var isVNode = __webpack_require__(23)
	var isVText = __webpack_require__(28)
	var isWidget = __webpack_require__(24)
	var isThunk = __webpack_require__(25)

	module.exports = handleThunk

	function handleThunk(a, b) {
	    var renderedA = a
	    var renderedB = b

	    if (isThunk(b)) {
	        renderedB = renderThunk(b, a)
	    }

	    if (isThunk(a)) {
	        renderedA = renderThunk(a, null)
	    }

	    return {
	        a: renderedA,
	        b: renderedB
	    }
	}

	function renderThunk(thunk, previous) {
	    var renderedThunk = thunk.vnode

	    if (!renderedThunk) {
	        renderedThunk = thunk.vnode = thunk.render(previous)
	    }

	    if (!(isVNode(renderedThunk) ||
	            isVText(renderedThunk) ||
	            isWidget(renderedThunk))) {
	        throw new Error("thunk did not return a valid node");
	    }

	    return renderedThunk
	}


/***/ }),
/* 43 */
/***/ (function(module, exports, __webpack_require__) {

	var isObject = __webpack_require__(44)
	var isHook = __webpack_require__(26)

	module.exports = diffProps

	function diffProps(a, b) {
	    var diff

	    for (var aKey in a) {
	        if (!(aKey in b)) {
	            diff = diff || {}
	            diff[aKey] = undefined
	        }

	        var aValue = a[aKey]
	        var bValue = b[aKey]

	        if (aValue === bValue) {
	            continue
	        } else if (isObject(aValue) && isObject(bValue)) {
	            if (getPrototype(bValue) !== getPrototype(aValue)) {
	                diff = diff || {}
	                diff[aKey] = bValue
	            } else if (isHook(bValue)) {
	                 diff = diff || {}
	                 diff[aKey] = bValue
	            } else {
	                var objectDiff = diffProps(aValue, bValue)
	                if (objectDiff) {
	                    diff = diff || {}
	                    diff[aKey] = objectDiff
	                }
	            }
	        } else {
	            diff = diff || {}
	            diff[aKey] = bValue
	        }
	    }

	    for (var bKey in b) {
	        if (!(bKey in a)) {
	            diff = diff || {}
	            diff[bKey] = b[bKey]
	        }
	    }

	    return diff
	}

	function getPrototype(value) {
	  if (Object.getPrototypeOf) {
	    return Object.getPrototypeOf(value)
	  } else if (value.__proto__) {
	    return value.__proto__
	  } else if (value.constructor) {
	    return value.constructor.prototype
	  }
	}


/***/ }),
/* 44 */
/***/ (function(module, exports) {

	"use strict";

	module.exports = function isObject(x) {
		return typeof x === "object" && x !== null;
	};


/***/ }),
/* 45 */
/***/ (function(module, exports, __webpack_require__) {

	var patch = __webpack_require__(46)

	module.exports = patch


/***/ }),
/* 46 */
/***/ (function(module, exports, __webpack_require__) {

	var document = __webpack_require__(47)
	var isArray = __webpack_require__(20)

	var render = __webpack_require__(49)
	var domIndex = __webpack_require__(51)
	var patchOp = __webpack_require__(52)
	module.exports = patch

	function patch(rootNode, patches, renderOptions) {
	    renderOptions = renderOptions || {}
	    renderOptions.patch = renderOptions.patch && renderOptions.patch !== patch
	        ? renderOptions.patch
	        : patchRecursive
	    renderOptions.render = renderOptions.render || render

	    return renderOptions.patch(rootNode, patches, renderOptions)
	}

	function patchRecursive(rootNode, patches, renderOptions) {
	    var indices = patchIndices(patches)

	    if (indices.length === 0) {
	        return rootNode
	    }

	    var index = domIndex(rootNode, patches.a, indices)
	    var ownerDocument = rootNode.ownerDocument

	    if (!renderOptions.document && ownerDocument !== document) {
	        renderOptions.document = ownerDocument
	    }

	    for (var i = 0; i < indices.length; i++) {
	        var nodeIndex = indices[i]
	        rootNode = applyPatch(rootNode,
	            index[nodeIndex],
	            patches[nodeIndex],
	            renderOptions)
	    }

	    return rootNode
	}

	function applyPatch(rootNode, domNode, patchList, renderOptions) {
	    if (!domNode) {
	        return rootNode
	    }

	    var newNode

	    if (isArray(patchList)) {
	        for (var i = 0; i < patchList.length; i++) {
	            newNode = patchOp(patchList[i], domNode, renderOptions)

	            if (domNode === rootNode) {
	                rootNode = newNode
	            }
	        }
	    } else {
	        newNode = patchOp(patchList, domNode, renderOptions)

	        if (domNode === rootNode) {
	            rootNode = newNode
	        }
	    }

	    return rootNode
	}

	function patchIndices(patches) {
	    var indices = []

	    for (var key in patches) {
	        if (key !== "a") {
	            indices.push(Number(key))
	        }
	    }

	    return indices
	}


/***/ }),
/* 47 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {var topLevel = typeof global !== 'undefined' ? global :
	    typeof window !== 'undefined' ? window : {}
	var minDoc = __webpack_require__(48);

	if (typeof document !== 'undefined') {
	    module.exports = document;
	} else {
	    var doccy = topLevel['__GLOBAL_DOCUMENT_CACHE@4'];

	    if (!doccy) {
	        doccy = topLevel['__GLOBAL_DOCUMENT_CACHE@4'] = minDoc;
	    }

	    module.exports = doccy;
	}

	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ }),
/* 48 */
/***/ (function(module, exports) {

	/* (ignored) */

/***/ }),
/* 49 */
/***/ (function(module, exports, __webpack_require__) {

	var document = __webpack_require__(47)

	var applyProperties = __webpack_require__(50)

	var isVNode = __webpack_require__(23)
	var isVText = __webpack_require__(28)
	var isWidget = __webpack_require__(24)
	var handleThunk = __webpack_require__(42)

	module.exports = createElement

	function createElement(vnode, opts) {
	    var doc = opts ? opts.document || document : document
	    var warn = opts ? opts.warn : null

	    vnode = handleThunk(vnode).a

	    if (isWidget(vnode)) {
	        return vnode.init()
	    } else if (isVText(vnode)) {
	        return doc.createTextNode(vnode.text)
	    } else if (!isVNode(vnode)) {
	        if (warn) {
	            warn("Item is not a valid virtual dom node", vnode)
	        }
	        return null
	    }

	    var node = (vnode.namespace === null) ?
	        doc.createElement(vnode.tagName) :
	        doc.createElementNS(vnode.namespace, vnode.tagName)

	    var props = vnode.properties
	    applyProperties(node, props)

	    var children = vnode.children

	    for (var i = 0; i < children.length; i++) {
	        var childNode = createElement(children[i], opts)
	        if (childNode) {
	            node.appendChild(childNode)
	        }
	    }

	    return node
	}


/***/ }),
/* 50 */
/***/ (function(module, exports, __webpack_require__) {

	var isObject = __webpack_require__(44)
	var isHook = __webpack_require__(26)

	module.exports = applyProperties

	function applyProperties(node, props, previous) {
	    for (var propName in props) {
	        var propValue = props[propName]

	        if (propValue === undefined) {
	            removeProperty(node, propName, propValue, previous);
	        } else if (isHook(propValue)) {
	            removeProperty(node, propName, propValue, previous)
	            if (propValue.hook) {
	                propValue.hook(node,
	                    propName,
	                    previous ? previous[propName] : undefined)
	            }
	        } else {
	            if (isObject(propValue)) {
	                patchObject(node, props, previous, propName, propValue);
	            } else {
	                node[propName] = propValue
	            }
	        }
	    }
	}

	function removeProperty(node, propName, propValue, previous) {
	    if (previous) {
	        var previousValue = previous[propName]

	        if (!isHook(previousValue)) {
	            if (propName === "attributes") {
	                for (var attrName in previousValue) {
	                    node.removeAttribute(attrName)
	                }
	            } else if (propName === "style") {
	                for (var i in previousValue) {
	                    node.style[i] = ""
	                }
	            } else if (typeof previousValue === "string") {
	                node[propName] = ""
	            } else {
	                node[propName] = null
	            }
	        } else if (previousValue.unhook) {
	            previousValue.unhook(node, propName, propValue)
	        }
	    }
	}

	function patchObject(node, props, previous, propName, propValue) {
	    var previousValue = previous ? previous[propName] : undefined

	    // Set attributes
	    if (propName === "attributes") {
	        for (var attrName in propValue) {
	            var attrValue = propValue[attrName]

	            if (attrValue === undefined) {
	                node.removeAttribute(attrName)
	            } else {
	                node.setAttribute(attrName, attrValue)
	            }
	        }

	        return
	    }

	    if(previousValue && isObject(previousValue) &&
	        getPrototype(previousValue) !== getPrototype(propValue)) {
	        node[propName] = propValue
	        return
	    }

	    if (!isObject(node[propName])) {
	        node[propName] = {}
	    }

	    var replacer = propName === "style" ? "" : undefined

	    for (var k in propValue) {
	        var value = propValue[k]
	        node[propName][k] = (value === undefined) ? replacer : value
	    }
	}

	function getPrototype(value) {
	    if (Object.getPrototypeOf) {
	        return Object.getPrototypeOf(value)
	    } else if (value.__proto__) {
	        return value.__proto__
	    } else if (value.constructor) {
	        return value.constructor.prototype
	    }
	}


/***/ }),
/* 51 */
/***/ (function(module, exports) {

	// Maps a virtual DOM tree onto a real DOM tree in an efficient manner.
	// We don't want to read all of the DOM nodes in the tree so we use
	// the in-order tree indexing to eliminate recursion down certain branches.
	// We only recurse into a DOM node if we know that it contains a child of
	// interest.

	var noChild = {}

	module.exports = domIndex

	function domIndex(rootNode, tree, indices, nodes) {
	    if (!indices || indices.length === 0) {
	        return {}
	    } else {
	        indices.sort(ascending)
	        return recurse(rootNode, tree, indices, nodes, 0)
	    }
	}

	function recurse(rootNode, tree, indices, nodes, rootIndex) {
	    nodes = nodes || {}


	    if (rootNode) {
	        if (indexInRange(indices, rootIndex, rootIndex)) {
	            nodes[rootIndex] = rootNode
	        }

	        var vChildren = tree.children

	        if (vChildren) {

	            var childNodes = rootNode.childNodes

	            for (var i = 0; i < tree.children.length; i++) {
	                rootIndex += 1

	                var vChild = vChildren[i] || noChild
	                var nextIndex = rootIndex + (vChild.count || 0)

	                // skip recursion down the tree if there are no nodes down here
	                if (indexInRange(indices, rootIndex, nextIndex)) {
	                    recurse(childNodes[i], vChild, indices, nodes, rootIndex)
	                }

	                rootIndex = nextIndex
	            }
	        }
	    }

	    return nodes
	}

	// Binary search for an index in the interval [left, right]
	function indexInRange(indices, left, right) {
	    if (indices.length === 0) {
	        return false
	    }

	    var minIndex = 0
	    var maxIndex = indices.length - 1
	    var currentIndex
	    var currentItem

	    while (minIndex <= maxIndex) {
	        currentIndex = ((maxIndex + minIndex) / 2) >> 0
	        currentItem = indices[currentIndex]

	        if (minIndex === maxIndex) {
	            return currentItem >= left && currentItem <= right
	        } else if (currentItem < left) {
	            minIndex = currentIndex + 1
	        } else  if (currentItem > right) {
	            maxIndex = currentIndex - 1
	        } else {
	            return true
	        }
	    }

	    return false;
	}

	function ascending(a, b) {
	    return a > b ? 1 : -1
	}


/***/ }),
/* 52 */
/***/ (function(module, exports, __webpack_require__) {

	var applyProperties = __webpack_require__(50)

	var isWidget = __webpack_require__(24)
	var VPatch = __webpack_require__(41)

	var updateWidget = __webpack_require__(53)

	module.exports = applyPatch

	function applyPatch(vpatch, domNode, renderOptions) {
	    var type = vpatch.type
	    var vNode = vpatch.vNode
	    var patch = vpatch.patch

	    switch (type) {
	        case VPatch.REMOVE:
	            return removeNode(domNode, vNode)
	        case VPatch.INSERT:
	            return insertNode(domNode, patch, renderOptions)
	        case VPatch.VTEXT:
	            return stringPatch(domNode, vNode, patch, renderOptions)
	        case VPatch.WIDGET:
	            return widgetPatch(domNode, vNode, patch, renderOptions)
	        case VPatch.VNODE:
	            return vNodePatch(domNode, vNode, patch, renderOptions)
	        case VPatch.ORDER:
	            reorderChildren(domNode, patch)
	            return domNode
	        case VPatch.PROPS:
	            applyProperties(domNode, patch, vNode.properties)
	            return domNode
	        case VPatch.THUNK:
	            return replaceRoot(domNode,
	                renderOptions.patch(domNode, patch, renderOptions))
	        default:
	            return domNode
	    }
	}

	function removeNode(domNode, vNode) {
	    var parentNode = domNode.parentNode

	    if (parentNode) {
	        parentNode.removeChild(domNode)
	    }

	    destroyWidget(domNode, vNode);

	    return null
	}

	function insertNode(parentNode, vNode, renderOptions) {
	    var newNode = renderOptions.render(vNode, renderOptions)

	    if (parentNode) {
	        parentNode.appendChild(newNode)
	    }

	    return parentNode
	}

	function stringPatch(domNode, leftVNode, vText, renderOptions) {
	    var newNode

	    if (domNode.nodeType === 3) {
	        domNode.replaceData(0, domNode.length, vText.text)
	        newNode = domNode
	    } else {
	        var parentNode = domNode.parentNode
	        newNode = renderOptions.render(vText, renderOptions)

	        if (parentNode && newNode !== domNode) {
	            parentNode.replaceChild(newNode, domNode)
	        }
	    }

	    return newNode
	}

	function widgetPatch(domNode, leftVNode, widget, renderOptions) {
	    var updating = updateWidget(leftVNode, widget)
	    var newNode

	    if (updating) {
	        newNode = widget.update(leftVNode, domNode) || domNode
	    } else {
	        newNode = renderOptions.render(widget, renderOptions)
	    }

	    var parentNode = domNode.parentNode

	    if (parentNode && newNode !== domNode) {
	        parentNode.replaceChild(newNode, domNode)
	    }

	    if (!updating) {
	        destroyWidget(domNode, leftVNode)
	    }

	    return newNode
	}

	function vNodePatch(domNode, leftVNode, vNode, renderOptions) {
	    var parentNode = domNode.parentNode
	    var newNode = renderOptions.render(vNode, renderOptions)

	    if (parentNode && newNode !== domNode) {
	        parentNode.replaceChild(newNode, domNode)
	    }

	    return newNode
	}

	function destroyWidget(domNode, w) {
	    if (typeof w.destroy === "function" && isWidget(w)) {
	        w.destroy(domNode)
	    }
	}

	function reorderChildren(domNode, moves) {
	    var childNodes = domNode.childNodes
	    var keyMap = {}
	    var node
	    var remove
	    var insert

	    for (var i = 0; i < moves.removes.length; i++) {
	        remove = moves.removes[i]
	        node = childNodes[remove.from]
	        if (remove.key) {
	            keyMap[remove.key] = node
	        }
	        domNode.removeChild(node)
	    }

	    var length = childNodes.length
	    for (var j = 0; j < moves.inserts.length; j++) {
	        insert = moves.inserts[j]
	        node = keyMap[insert.key]
	        // this is the weirdest bug i've ever seen in webkit
	        domNode.insertBefore(node, insert.to >= length++ ? null : childNodes[insert.to])
	    }
	}

	function replaceRoot(oldRoot, newRoot) {
	    if (oldRoot && newRoot && oldRoot !== newRoot && oldRoot.parentNode) {
	        oldRoot.parentNode.replaceChild(newRoot, oldRoot)
	    }

	    return newRoot;
	}


/***/ }),
/* 53 */
/***/ (function(module, exports, __webpack_require__) {

	var isWidget = __webpack_require__(24)

	module.exports = updateWidget

	function updateWidget(a, b) {
	    if (isWidget(a) && isWidget(b)) {
	        if ("name" in a && "name" in b) {
	            return a.id === b.id
	        } else {
	            return a.init === b.init
	        }
	    }

	    return false
	}


/***/ }),
/* 54 */
/***/ (function(module, exports, __webpack_require__) {

	var createElement = __webpack_require__(49)

	module.exports = createElement


/***/ }),
/* 55 */
/***/ (function(module, exports, __webpack_require__) {

	var Token = __webpack_require__(56);

	// program
	__webpack_require__(62);
	__webpack_require__(64);

	// html markup
	__webpack_require__(65);
	__webpack_require__(66);
	__webpack_require__(67);
	__webpack_require__(68);

	// bars markup
	__webpack_require__(69);
	__webpack_require__(70);
	__webpack_require__(71);

	// bars expression
	__webpack_require__(72);
	__webpack_require__(73);
	__webpack_require__(74);
	__webpack_require__(75);

	// context-maps
	__webpack_require__(76);

	module.exports = Token;
	// module.exports = window.Token = Token;




	// test

	// var prog = new Token.tokens.program();
	//
	// prog.fragment = new Token.tokens.fragment();
	//
	// for (var i = 0; i < 5; i++) {
	//     prog.fragment.nodes.push(new Token.tokens.tag());
	// }

	// window.prog = prog;


/***/ }),
/* 56 */
/***/ (function(module, exports, __webpack_require__) {

	var Token = __webpack_require__(57)
	    .Token;

	var BarsToken = Token.generate(
	    function BarsToken(code, type) {
	        Token.call(this, code, type);
	    }
	);

	BarsToken.tokens = [];

	BarsToken.definePrototype({
	    writable: true
	}, {
	    indentLevel: '',
	    JSONuseObject: true
	});

	BarsToken.definePrototype({
	    TYPE_ID: -1,

	    toJSON: function toJSON(arr) {
	        if (this.JSONuseObject)
	            return this.toObject();
	        return this.toArray();
	    },

	    toArray: function toArray() {
	        var _ = this;

	        console.warn('toArray not impleneted.');
	        return [-1];
	    },

	    toObject: function toObject() {
	        var _ = this;

	        console.warn('toObject not impleneted.');
	        return {
	            type: _.type,
	            TYPE_ID: _.TYPE_ID
	        };
	    },
	    fromArray: function fromArray(arr) {
	        var _ = this;
	        if (arr[0] !== _.TYPE_ID) {
	            throw 'TypeMismatch: ' + arr[0] + ' is not ' + _.TYPE_ID;
	        }

	        _._fromArray(arr);
	    },
	    updates: function updates() {
	        var _ = this;
	        console.warn('updates not impleneted.');
	    }
	});

	module.exports = BarsToken;


/***/ }),
/* 57 */
/***/ (function(module, exports, __webpack_require__) {

	exports.Compiler = __webpack_require__(58);
	exports.Token = __webpack_require__(60);


/***/ }),
/* 58 */
/***/ (function(module, exports, __webpack_require__) {

	var Generator = __webpack_require__(13),
	    Scope = __webpack_require__(59),
	    Token = __webpack_require__(60),
	    CodeBuffer = __webpack_require__(61),
	    utils = __webpack_require__(16);

	var Compiler = Generator.generate(
	    function Compiler(parseModes, formaters) {
	        var _ = this;

	        _.modeFormater = formaters.modeFormater || utils.varThrough;
	        _.charFormater = formaters.charFormater || utils.varThrough;
	        _.funcFormater = formaters.funcFormater || utils.varThrough;
	        _.typeFormater = formaters.typeFormater || utils.varThrough;
	        _.sourceFormater = formaters.sourceFormater || utils.varThrough;

	        _.parseModes = parseModes;
	        _.scope = new Scope();
	    }
	);

	Compiler.definePrototype({
	    compile: function compile(codeStr, file, mode, flags) {
	        var _ = this,
	            tokens = [];

	        _.codeBuffer = new CodeBuffer(codeStr, file);

	        _.scope.verbose = flags.verbose;

	        if (flags.verbose) {
	            _.scope.printScope();
	        }

	        _.parseMode(mode, tokens, flags);

	        if (flags.verbose) {
	            _.scope.printScope();
	        }

	        if (_.scope.length) {
	            throw _.codeBuffer.makeError(
	                'Unexpected End Of Input.'
	            );
	        }

	        return tokens;
	    },

	    parseMode: function parseMode(mode, tokens, flags) {
	        var _ = this,
	            scope = _.scope,
	            code = _.codeBuffer,
	            token,
	            parseFuncs = _.parseModes[mode],
	            index = code.index;

	        if (!parseFuncs) {
	            throw new Error('Mode not found: ' + JSON.stringify(
	                mode) + '.');
	        }

	        function newParseMode(mode, tokens, flags) {
	            _.parseMode(mode, tokens, flags);
	        }

	        newParseMode.close = function () {
	            this.closed = true;
	        };

	        loop: while (code.left) {

	            for (var i = 0; i < parseFuncs.length; i++) {
	                var parseFunc = parseFuncs[i];

	                if (flags.verbose) {
	                    console.log(
	                        utils.repeat('  ', scope.length +
	                            1) +
	                        _.modeFormater(mode) + ' ' +
	                        _.funcFormater(parseFunc.name) +
	                        '\n' +
	                        utils.repeat('  ', scope.length +
	                            1) +
	                        utils.bufferSlice(code, 5, _.charFormater)
	                    );
	                }

	                token = parseFunc(
	                    mode,
	                    code,
	                    tokens,
	                    flags,
	                    scope,
	                    newParseMode
	                );

	                if (token) {
	                    if (token instanceof Token) {
	                        tokens.push(token);

	                        if (flags.verbose) {
	                            console.log(
	                                utils.repeat('  ', scope.length +
	                                    1) +
	                                _.typeFormater(token.constructor
	                                    .name || token.type) +
	                                ': ' +
	                                _.sourceFormater(token.source())
	                            );
	                        }
	                    }

	                    if (newParseMode.closed) {
	                        delete newParseMode.closed;
	                        break loop;
	                    }

	                    break;
	                }
	            }

	            if (newParseMode.closed) {
	                delete newParseMode.closed;
	                break loop;
	            }

	            if (index === code.index) {
	                token = new Token(code);
	                token.close(code);
	                token.value = token.source(code);

	                if (flags.noErrorOnILLEGAL) {
	                    tokens.push(token);
	                } else {
	                    throw code.makeError(
	                        token.range[0],
	                        token.range[1],
	                        'ILLEGAL Token: ' +
	                        JSON.stringify(
	                            token.source(code)
	                        )
	                        .slice(1, -1)
	                    );
	                }
	            }

	            index = code.index;
	        }
	    }
	});

	module.exports = Compiler;


/***/ }),
/* 59 */
/***/ (function(module, exports, __webpack_require__) {

	var Generator = __webpack_require__(13),
	    Token = __webpack_require__(60),
	    utils = __webpack_require__(16);

	var Scope = Generator.generate(
	    function Scope() {
	        var _ = this;

	        _.defineProperties({
	            _scope: []
	        });
	    }
	);

	Scope.definePrototype({
	    push: function push(token) {
	        var _ = this;

	        utils.assertError(Token.isCreation(token), 'Invalid Type.');

	        _._scope.push(token);

	        if (_.verbose) {
	            _.printScope();
	        }

	        return _._scope.length;
	    },
	    pop: function pop() {
	        var _ = this;

	        var token = _._scope.pop();

	        if (_.verbose) {
	            _.printScope();
	        }

	        return token;
	    },
	    close: function close() {
	        var _ = this;

	        var token = _._scope.pop();

	        token.close();

	        if (_.verbose) {
	            _.printScope();
	        }

	        return token;
	    },
	    printScope: function printScope() {
	        var _ = this;

	        console.log(
	            ['Main'].concat(
	                _._scope
	                .map(function (item) {
	                    return item.constructor.name ||
	                        item.type;
	                })
	            )
	            .join(' => ')
	        );
	    },
	    token: {
	        get: function getToken() {
	            var _ = this;

	            return _._scope[_._scope.length - 1];
	        }
	    },
	    length: {
	        get: function getLength() {
	            var _ = this;

	            return _._scope.length;
	        }
	    }
	});

	module.exports = Scope;


/***/ }),
/* 60 */
/***/ (function(module, exports, __webpack_require__) {

	var Generator = __webpack_require__(13),
	    utils = __webpack_require__(16);

	var Token = Generator.generate(
	    function Token(code, type) {
	        var _ = this;

	        _.defineProperties({
	            code: code
	        });

	        _.type = type;
	        _.range = [code.index, code.index + 1];
	        _.loc = {
	            start: {
	                line: code.line,
	                column: code.column
	            },
	            end: {
	                line: code.line,
	                column: code.column + 1
	            }
	        };
	    }
	);

	Token.definePrototype({
	    writable: true,
	    enumerable: true
	}, {
	    type: 'ILLEGAL'
	});

	Token.definePrototype({
	    length: {
	        get: function getLength() {
	            return this.range[1] - this.range[0];
	        }
	    },
	    source: function source() {
	        var _ = this;
	        return _.code.slice(_.range[0], _.range[1]);
	    },
	    close: function close() {
	        var _ = this;

	        if (_.closed) {
	            throw new Error('Cannot call close on a closed token.');
	        }

	        _.closed = true;

	        if (_.code.index > _.range[1]) {
	            _.range[1] = _.code.index;
	            _.loc.end = {
	                line: _.code.line,
	                column: _.code.column
	            };
	        }
	    }
	});

	module.exports = Token;


/***/ }),
/* 61 */
/***/ (function(module, exports, __webpack_require__) {

	var Generator = __webpack_require__(13),
	    utils = __webpack_require__(16);

	var CodeBuffer = Generator.generate(
	    function CodeBuffer(str, file) {
	        var _ = this;

	        _.reset();
	        _._buffer = str;
	        _._file = file;
	    }
	);

	CodeBuffer.definePrototype({
	    reset: function reset() {
	        var _ = this;

	        _.line = 1;
	        _.column = 1;
	        _._index = 0;
	        _._currentLine = 0;
	    },
	    currentLine: {
	        get: function currentLine() {
	            var _ = this,
	                lineText = '',
	                i = _._currentLine;

	            while (i < _.length) {
	                lineText += _._buffer[i];
	                if (_._buffer.codePointAt(i) === 10) {
	                    break;
	                }
	                i++;
	            }

	            return lineText;
	        }
	    },

	    buffer: {
	        get: function getBuffer() {
	            var _ = this;

	            return _._buffer;
	        }
	    },


	    index: {
	        get: function getIndex() {
	            var _ = this;

	            return _._index;
	        },

	        set: function setIndex(val) {
	            var _ = this,
	                i = _._index,
	                update = false;

	            val = Math.min(_.length, val);
	            val = Math.max(0, val);

	            if (i == val) return;

	            if (i > val) {
	                // throw new Error('========' + val + ' < ' +i+'=======');
	                _.reset();
	                i = _._index;
	            }

	            if (_.buffer.codePointAt(i) === 10) {
	                update = true;
	                i++;
	            }

	            for (; i <= val; i++) {
	                if (update) {
	                    _._currentLine = i;
	                    _.line++;
	                    update = false;
	                } else {
	                    _.column++;
	                }

	                if (_.buffer.codePointAt(i) === 10) {
	                    update = true;
	                }
	            }
	            _.column = val - _._currentLine + 1;
	            _._index = val;
	        }
	    },

	    length: {
	        get: function getLength() {
	            var _ = this;

	            return _._buffer.length;
	        }
	    },

	    next: function next() {
	        var _ = this;

	        _.index++;
	        return _.charAt(_.index);
	    },

	    left: {
	        get: function getLeft() {
	            var _ = this;

	            return _._index < _.length;
	        }
	    },

	    charAt: function charAt(i) {
	        var _ = this;

	        return _._buffer[i] || 'EOF';
	    },

	    codePointAt: function codePointAt(i) {
	        var _ = this;

	        return _._buffer.codePointAt(i);
	    },

	    slice: function slice(startIndex, endIndex) {
	        var _ = this;

	        return _._buffer.slice(startIndex, endIndex);
	    },

	    makeError: function makeError(start, end, message) {
	        var _ = this;

	        utils.assertTypeError(start, 'number');
	        utils.assertTypeError(end, 'number');
	        utils.assertTypeError(message, 'string');

	        _.index = start;

	        var currentLine = _.currentLine,
	            tokenLength = end - start,
	            tokenIdentifier =
	            currentLine[currentLine.length - 1] === '\n' ? '' :
	            '\n',
	            i;

	        for (i = 1; i < _.column; i++) {
	            tokenIdentifier += ' ';
	        }

	        tokenLength = Math.min(
	            tokenLength,
	            currentLine.length - tokenIdentifier.length
	        ) || 1;

	        for (i = 0; i < tokenLength; i++) {
	            tokenIdentifier += '^';
	        }

	        return 'Syntax Error: ' +
	            message +
	            ' at ' +
	            (_._file ? _._file + ':' : '') +
	            _.line +
	            ':' +
	            _.column +
	            '\n\n' +
	            currentLine +
	            tokenIdentifier +
	            '\n';
	    }
	});

	module.exports = CodeBuffer;


/***/ }),
/* 62 */
/***/ (function(module, exports, __webpack_require__) {

	var Token = __webpack_require__(56);
	var PACKAGE_JSON = __webpack_require__(63);

	var ProgramToken = Token.generate(
	    function ProgramToken(code) {
	        var _ = this;

	        if (code) {
	            Token.call(_, code);
	        }

	        _.version = PACKAGE_JSON.version;
	        _.mode = '';

	        _.fragment = null;
	    }
	);

	ProgramToken.definePrototype({
	    enumerable: true
	}, {
	    type: 'program'
	});

	ProgramToken.definePrototype({
	    writable: true
	}, {
	    indentLevel: '\n'
	});

	ProgramToken.definePrototype({
	    TYPE_ID: Token.tokens.push(ProgramToken) - 1,
	    toArray: function () {
	        var _ = this;
	        return [
	            _.TYPE_ID,
	            _.version,
	            _.mode,
	            _.fragment
	        ];
	    },

	    toObject: function () {
	        var _ = this;
	        return {
	            type: _.type,
	            TYPE_ID: _.TYPE_ID,
	            version: _.version,
	            mode: _.mode,
	            fragment: _.fragment
	        };
	    },

	    _fromArray: function _fromArray(arr) {
	        var _ = this;

	        _.version = arr[1];
	        _.mode = arr[2];

	        var fragment = new Token.tokens.fragment();

	        fragment.fromArray(arr[3]);

	        _.fragment = fragment;
	    },
	    toString: function toString() {
	        var _ = this;

	        _.fragment.indentLevel = _.indentLevel;

	        return _.fragment.toString()
	            .trim() + '\n';
	    }
	});

	Token.tokens.program = ProgramToken;


/***/ }),
/* 63 */
/***/ (function(module, exports) {

	module.exports = {
		"name": "bars",
		"version": "1.6.0",
		"description": "Bars is a lightweight high performance HTML aware templating engine.",
		"main": "index.js",
		"scripts": {
			"test": "echo \"Error: no test specified\" && exit 1"
		},
		"repository": {
			"type": "git",
			"url": "git+https://github.com/Mike96Angelo/Bars.git"
		},
		"keywords": [
			"bars",
			"render",
			"renderer",
			"rendering",
			"template",
			"templating",
			"html"
		],
		"author": "Michaelangelo Jong",
		"license": "MIT",
		"bugs": {
			"url": "https://github.com/Mike96Angelo/Bars/issues"
		},
		"homepage": "https://github.com/Mike96Angelo/Bars#readme",
		"dependencies": {
			"compileit": "^1.0.1",
			"generate-js": "^3.1.2",
			"jquery": "^3.1.1",
			"source-map": "^0.5.6",
			"virtual-dom": "^2.1.1"
		},
		"devDependencies": {
			"browserify": "^13.1.1",
			"colors": "^1.1.2",
			"gulp": "^3.9.1",
			"gulp-minify": "0.0.14",
			"stringify": "^5.1.0",
			"vinyl-buffer": "^1.0.0",
			"vinyl-source-stream": "^1.1.0"
		}
	};

/***/ }),
/* 64 */
/***/ (function(module, exports, __webpack_require__) {

	var Token = __webpack_require__(56);

	var FragmentToken = Token.generate(
	    function FragmentToken(code) {
	        var _ = this;

	        if (code) {
	            Token.call(_, code);
	        }

	        _.nodes = [];

	        _.nodesUpdate = 0;
	    }
	);


	FragmentToken.definePrototype({
	    enumerable: true
	}, {
	    type: 'fragment'
	});

	FragmentToken.definePrototype({
	    TYPE_ID: Token.tokens.push(FragmentToken) - 1,
	    toArray: function () {
	        var _ = this;
	        return [
	            _.TYPE_ID,
	            _.nodes,
	            _.nodesUpdate
	        ];
	    },

	    toObject: function () {
	        var _ = this;
	        return {
	            type: _.type,
	            TYPE_ID: _.TYPE_ID,
	            nodes: _.nodes,
	            nodesUpdate: _.nodesUpdate
	        };
	    },

	    _fromArray: function _fromArray(arr) {
	        var _ = this;

	        _.nodes = arr[1].map(function (item) {
	            var node = new Token.tokens[item[0]]();

	            node.fromArray(item);

	            return node;
	        });

	        _.nodesUpdate = arr[2];
	    },

	    toString: function toString() {
	        var _ = this,
	            str = '';

	        for (var i = 0; i < _.nodes.length; i++) {
	            _.nodes[i].indentLevel = _.indentLevel;
	            str += _.nodes[i].toString();
	        }

	        return str;
	    },
	    updates: function updates() {
	        var _ = this;

	        _.nodesUpdate = 1;
	    }
	});

	Token.tokens.fragment = FragmentToken;


/***/ }),
/* 65 */
/***/ (function(module, exports, __webpack_require__) {

	var Token = __webpack_require__(56);

	var TextToken = Token.generate(
	    function TextToken(code) {
	        var _ = this;

	        if (code) {
	            Token.call(_, code);
	        }

	        _.value = '';
	    }
	);


	TextToken.definePrototype({
	    enumerable: true
	}, {
	    type: 'text'
	});

	TextToken.definePrototype({
	    TYPE_ID: Token.tokens.push(TextToken) - 1,
	    toArray: function () {
	        var _ = this;
	        return [
	            _.TYPE_ID,
	            _.value
	        ];
	    },

	    toObject: function () {
	        var _ = this;
	        return {
	            type: _.type,
	            TYPE_ID: _.TYPE_ID,
	            value: _.value
	        };
	    },

	    _fromArray: function _fromArray(arr) {
	        var _ = this;

	        _.value = arr[1];
	    },

	    toString: function toString() {
	        var _ = this,
	            str = '';

	        str += _.indentLevel + _.value;

	        return str;
	    }
	});

	Token.tokens.text = TextToken;


/***/ }),
/* 66 */
/***/ (function(module, exports, __webpack_require__) {

	var Token = __webpack_require__(56);

	var TagToken = Token.generate(
	    function TagToken(code) {
	        var _ = this;

	        if (code) {
	            Token.call(_, code);
	        }

	        _.name = '';

	        _.attrs = [];
	        _.props = [];
	        _.nodes = [];

	        _.attrsUpdate = 0;
	        _.nodesUpdate = 0;
	    }
	);


	TagToken.definePrototype({
	    enumerable: true
	}, {
	    type: 'tag'
	});

	TagToken.definePrototype({
	    TYPE_ID: Token.tokens.push(TagToken) - 1,
	    toArray: function () {
	        var _ = this;
	        return [
	            _.TYPE_ID,
	            _.name,
	            _.attrs,
	            _.attrsUpdate,
	            _.nodes,
	            _.nodesUpdate,
	            _.props
	        ];
	    },

	    toObject: function () {
	        var _ = this;
	        return {
	            type: _.type,
	            TYPE_ID: _.TYPE_ID,
	            name: _.name,
	            attrs: _.attrs,
	            attrsUpdate: _.attrsUpdate,
	            nodes: _.nodes,
	            nodesUpdate: _.nodesUpdate,
	            props: _.props
	        };
	    },

	    _fromArray: function _fromArray(arr) {
	        var _ = this;

	        _.name = arr[1];

	        _.attrs = arr[2].map(function (item) {
	            var attr = new Token.tokens[item[0]]();

	            attr.fromArray(item);

	            return attr;
	        });

	        _.attrsUpdate = arr[3];

	        _.nodes = arr[4].map(function (item) {
	            var node = new Token.tokens[item[0]]();

	            node.fromArray(item);

	            return node;
	        });

	        _.nodesUpdate = arr[5];

	        _.props = arr[6].map(function (item) {
	            var prop = new Token.tokens[item[0]]();

	            prop.fromArray(item);

	            return prop;
	        });
	    },

	    toString: function toString() {
	        var _ = this,
	            str = _.indentLevel + '<' + _.name;

	        for (var i = 0; i < _.attrs.length; i++) {
	            str += _.attrs[i].toString();
	        }

	        if (_.selfClosed) {
	            str += (_.attrs.length ? ' ' : '') + '/>'; 
	            return str;
	        }

	        str += '>'; 
	        if (_.selfClosing) {
	            return str;
	        }
	        var nodes = '';
	        for (i = 0; i < _.nodes.length; i++) {
	            _.nodes[i].indentLevel = (_.indentLevel ? _.indentLevel +
	                '  ' : '');
	            nodes += _.nodes[i].toString();
	        }

	        str += nodes.trim();

	        str += _.indentLevel + '</' + _.name + '>';

	        return str;
	    },

	    updates: function updates(type) {
	        var _ = this;

	        if (type === 'attr') {
	            _.attrsUpdate = 1;
	        } else {
	            _.nodesUpdate = 1;
	        }
	    }
	});

	Token.tokens.tag = TagToken;


/***/ }),
/* 67 */
/***/ (function(module, exports, __webpack_require__) {

	var Token = __webpack_require__(56);

	var AttrToken = Token.generate(
	    function AttrToken(code) {
	        var _ = this;

	        if (code) {
	            Token.call(_, code);
	        }

	        _.name = '';

	        _.nodes = [];

	        _.nodesUpdate = 0;
	    }
	);


	AttrToken.definePrototype({
	    enumerable: true
	}, {
	    type: 'attr'
	});

	AttrToken.definePrototype({
	    TYPE_ID: Token.tokens.push(AttrToken) - 1,
	    toArray: function () {
	        var _ = this;
	        return [
	            _.TYPE_ID,
	            _.name,
	            _.nodes,
	            _.nodesUpdate
	        ];
	    },

	    toObject: function () {
	        var _ = this;
	        return {
	            type: _.type,
	            TYPE_ID: _.TYPE_ID,
	            name: _.name,
	            nodes: _.nodes,
	            nodesUpdate: _.nodesUpdate
	        };
	    },

	    _fromArray: function _fromArray(arr) {
	        var _ = this;

	        _.name = arr[1];

	        _.nodes = arr[2].map(function (item) {
	            var node = new Token.tokens[item[0]]();

	            node.fromArray(item);

	            return node;
	        });

	        _.nodesUpdate = arr[3];
	    },

	    toString: function toString() {
	        var _ = this,
	            str = ' ';

	        str += _.name + (_.nodes.length ? '="' : '');

	        for (var i = 0; i < _.nodes.length; i++) {

	            _.nodes[i].indentLevel = '';

	            str += _.nodes[i].toString();
	        }

	        str += (_.nodes.length ? '"' : '');

	        return str;
	    },
	    updates: function updates() {
	        var _ = this;

	        _.nodesUpdate = 1;
	    }
	});

	Token.tokens.attr = AttrToken;


/***/ }),
/* 68 */
/***/ (function(module, exports, __webpack_require__) {

	var Token = __webpack_require__(56);

	var PropToken = Token.generate(
	    function PropToken(code) {
	        var _ = this;

	        if (code) {
	            Token.call(_, code);
	        }

	        _.name = '';
	        _.expression = null;
	    }
	);


	PropToken.definePrototype({
	    enumerable: true
	}, {
	    type: 'prop'
	});

	PropToken.definePrototype({
	    TYPE_ID: Token.tokens.push(PropToken) - 1,
	    toArray: function () {
	        var _ = this;
	        return [
	            _.TYPE_ID,
	            _.name,
	            _.expression
	        ];
	    },

	    toObject: function () {
	        var _ = this;
	        return {
	            type: _.type,
	            TYPE_ID: _.TYPE_ID,
	            name: _.name,
	            expression: _.expression
	        };
	    },

	    _fromArray: function _fromArray(arr) {
	        var _ = this;

	        _.name = arr[1];

	        var expression = new Token.tokens[arr[2][0]]();

	        expression.fromArray(arr[2]);

	        _.expression = expression;
	    },

	    toString: function toString() {
	        var _ = this,
	            str = _.name + ':{{ ';
	        str += _.expression.toString();
	        str += ' }}';
	        return str;
	    }
	});

	Token.tokens.prop = PropToken;


/***/ }),
/* 69 */
/***/ (function(module, exports, __webpack_require__) {

	var Token = __webpack_require__(56);

	var BlockToken = Token.generate(
	    function BlockToken(code) {
	        var _ = this;

	        if (code) {
	            Token.call(_, code);
	        }

	        _.name = '';

	        _.arguments = null;
	        _.map = null;

	        _.consequent = null;
	        _.alternate = null;
	    }
	);


	BlockToken.definePrototype({
	    enumerable: true
	}, {
	    type: 'block'
	});

	BlockToken.definePrototype({
	    TYPE_ID: Token.tokens.push(BlockToken) - 1,
	    toArray: function () {
	        var _ = this;
	        return [
	            _.TYPE_ID,
	            _.name,
	            _.arguments,
	            _.map,
	            _.consequent,
	            _.alternate
	        ];
	    },

	    toObject: function () {
	        var _ = this;
	        return {
	            type: _.type,
	            TYPE_ID: _.TYPE_ID,
	            name: _.name,
	            arguments: _.arguments,
	            map: _.map,
	            consequent: _.consequent,
	            alternate: _.alternate
	        };
	    },

	    _fromArray: function _fromArray(arr) {
	        var _ = this;

	        _.name = arr[1];

	        _.arguments = arr[2].map(function (item) {
	            var arg = new Token.tokens[item[0]]();

	            arg.fromArray(item);

	            return arg;
	        });

	        _.map = arr[3].map(function (item) {
	            var arg = new Token.tokens[item[0]]();

	            arg.fromArray(item);

	            return arg;
	        });

	        var consequent = new Token.tokens.fragment();

	        consequent.fromArray(arr[4]);

	        _.consequent = consequent;

	        if (arr[5]) {
	            var alternate = new Token.tokens[arr[5][0]]();

	            alternate.fromArray(arr[5]);

	            _.alternate = alternate;
	        }
	    },

	    toString: function toString() {
	        var _ = this,
	            str = '';

	        if (!_.fromElse) {
	            str += _.indentLevel + '{{#';
	        }

	        str += _.name + ' ';

	        str += _.expression.toString();
	        str += (_.map ? _.map.toString() : '');

	        str += '}}';

	        _.consequent.indentLevel = (_.indentLevel ? _.indentLevel +
	            '  ' : '');
	        str += _.consequent.toString();

	        if (_.alternate) {
	            _.alternate.indentLevel = _.indentLevel;
	            if (_.alternate.type === 'block') {
	                _.alternate.fromElse = true;
	                str += _.indentLevel + '{{else ' + _.alternate.toString();
	                return str;
	            }
	            _.alternate.indentLevel += (_.indentLevel ? _.indentLevel +
	                '  ' : '');

	            str += _.indentLevel + '{{else}}';
	            str += _.alternate.toString();
	        }

	        str += _.indentLevel + '{{/' + _.name + '}}';

	        return str;
	    },
	    updates: function updates() {
	        var _ = this;

	        if (_.elsed && _.alternate) {
	            _.alternate.nodesUpdate = 1;
	        } else if (_.consequent) {
	            _.consequent.nodesUpdate = 1;
	        }
	    }
	});

	Token.tokens.block = BlockToken;


/***/ }),
/* 70 */
/***/ (function(module, exports, __webpack_require__) {

	var Token = __webpack_require__(56);

	var InsertToken = Token.generate(
	    function InsertToken(code) {
	        var _ = this;

	        if (code) {
	            Token.call(_, code);
	        }

	        _.expression = null;
	    }
	);


	InsertToken.definePrototype({
	    enumerable: true
	}, {
	    type: 'insert'
	});

	InsertToken.definePrototype({
	    TYPE_ID: Token.tokens.push(InsertToken) - 1,
	    toArray: function () {
	        var _ = this;
	        return [
	            _.TYPE_ID,
	            _.expression
	        ];
	    },

	    toObject: function () {
	        var _ = this;
	        return {
	            type: _.type,
	            TYPE_ID: _.TYPE_ID,
	            expression: _.expression
	        };
	    },

	    _fromArray: function _fromArray(arr) {
	        var _ = this;

	        var expression = new Token.tokens[arr[1][0]]();

	        expression.fromArray(arr[1]);

	        _.expression = expression;
	    },

	    toString: function toString() {
	        var _ = this,
	            str = '{{ ';
	        str += _.expression.toString();
	        str += ' }}';
	        return str;
	    }
	});

	Token.tokens.insert = InsertToken;


/***/ }),
/* 71 */
/***/ (function(module, exports, __webpack_require__) {

	var Token = __webpack_require__(56);

	var PartialToken = Token.generate(
	    function PartialToken(code) {
	        var _ = this;

	        if (code) {
	            Token.call(_, code);
	        }

	        _.name = '';

	        _.expression = null;
	        _.map = null;
	    }
	);


	PartialToken.definePrototype({
	    enumerable: true
	}, {
	    type: 'partial'
	});

	PartialToken.definePrototype({
	    TYPE_ID: Token.tokens.push(PartialToken) - 1,
	    toArray: function () {
	        var _ = this;
	        return [
	            _.TYPE_ID,
	            _.name,
	            _.expression,
	            _.map
	        ];
	    },

	    toObject: function () {
	        var _ = this;
	        return {
	            type: _.type,
	            TYPE_ID: _.TYPE_ID,
	            name: _.name,
	            expression: _.expression,
	            map: _.map
	        };
	    },

	    _fromArray: function _fromArray(arr) {
	        var _ = this;

	        _.name = arr[1];

	        if (arr[2]) {
	            var expression = new Token.tokens[arr[2][0]]();

	            expression.fromArray(arr[2]);

	            _.expression = expression;
	        }

	        _.map = arr[3].map(function (item) {
	            var arg = new Token.tokens[item[0]]();

	            arg.fromArray(item);

	            return arg;
	        });
	    },
	    toString: function toString() {
	        var _ = this,
	            str = _.indentLevel + '{{>' + _.name;
	        str += (_.expression ? ' ' + _.expression.toString() : '');
	        str += '}}';
	        return str;
	    }
	});

	Token.tokens.partial = PartialToken;


/***/ }),
/* 72 */
/***/ (function(module, exports, __webpack_require__) {

	var Token = __webpack_require__(56);

	var LiteralToken = Token.generate(
	    function LiteralToken(code) {
	        var _ = this;

	        if (code) {
	            Token.call(_, code);
	        }

	        _.value = '';
	    }
	);


	LiteralToken.definePrototype({
	    enumerable: true
	}, {
	    type: 'literal'
	});

	LiteralToken.definePrototype({
	    TYPE_ID: Token.tokens.push(LiteralToken) - 1,
	    toArray: function () {
	        var _ = this;
	        return [
	            _.TYPE_ID,
	            _.value
	        ];
	    },

	    toObject: function () {
	        var _ = this;
	        return {
	            type: _.type,
	            TYPE_ID: _.TYPE_ID,
	            value: _.value
	        };
	    },

	    _fromArray: function _fromArray(arr) {
	        var _ = this;

	        _.value = arr[1];
	    },
	    toString: function toString() {
	        var _ = this,
	            str = '';

	        str += _.value;

	        return str;
	    }
	});

	Token.tokens.literal = LiteralToken;


/***/ }),
/* 73 */
/***/ (function(module, exports, __webpack_require__) {

	var Token = __webpack_require__(56);

	var ValueToken = Token.generate(
	    function ValueToken(code) {
	        var _ = this;

	        if (code) {
	            Token.call(_, code);
	        }

	        _.path = '';
	    }
	);


	ValueToken.definePrototype({
	    enumerable: true
	}, {
	    type: 'value'
	});

	ValueToken.definePrototype({
	    TYPE_ID: Token.tokens.push(ValueToken) - 1,
	    toArray: function () {
	        var _ = this;
	        return [
	            _.TYPE_ID,
	            _.path
	        ];
	    },

	    toObject: function () {
	        var _ = this;
	        return {
	            type: _.type,
	            TYPE_ID: _.TYPE_ID,
	            path: _.path
	        };
	    },

	    _fromArray: function _fromArray(arr) {
	        var _ = this;

	        _.path = arr[1];
	    },

	    toString: function toString() {
	        var _ = this,
	            str = '';

	        if (
	            _.path[0] === '~' ||
	            _.path[0] === '..' ||
	            _.path[0] === '.' ||
	            _.path[0] === '@'
	        ) {
	            str += _.path.join('/');
	        } else {
	            str += _.path.join('.');
	        }

	        return str;
	    }
	});

	Token.tokens.value = ValueToken;


/***/ }),
/* 74 */
/***/ (function(module, exports, __webpack_require__) {

	var Token = __webpack_require__(56);

	var TransformToken = Token.generate(
	    function TransformToken(code) {
	        var _ = this;

	        if (code) {
	            Token.call(_, code);
	        }

	        _.name = '';

	        _.arguments = [];
	    }
	);


	TransformToken.definePrototype({
	    enumerable: true
	}, {
	    type: 'transform'
	});

	TransformToken.definePrototype({
	    TYPE_ID: Token.tokens.push(TransformToken) - 1,
	    toArray: function () {
	        var _ = this;
	        return [
	            _.TYPE_ID,
	            _.name,
	            _.arguments
	        ];
	    },

	    toObject: function () {
	        var _ = this;
	        return {
	            type: _.type,
	            TYPE_ID: _.TYPE_ID,
	            name: _.name,
	            arguments: _.arguments
	        };
	    },

	    _fromArray: function _fromArray(arr) {
	        var _ = this;

	        _.name = arr[1];

	        _.arguments = arr[2].map(function (item) {
	            var arg = new Token.tokens[item[0]]();

	            arg.fromArray(item);

	            return arg;
	        });
	    },

	    toString: function toString() {
	        var _ = this,
	            str = '@';

	        str += _.name + '(';

	        for (var i = 0; i < _.arguments.length; i++) {

	            str += _.arguments[i].toString() + (i + 1 < _.arguments
	                .length ?
	                ', ' : '');
	        }

	        str += ')';

	        return str;
	    }
	});

	Token.tokens.transform = TransformToken;


/***/ }),
/* 75 */
/***/ (function(module, exports, __webpack_require__) {

	var Token = __webpack_require__(56);

	var OperatorToken = Token.generate(
	    function OperatorToken(code) {
	        var _ = this;

	        if (code) {
	            Token.call(_, code);
	        }

	        _.operator = '';

	        _.operands = [];
	    }
	);


	OperatorToken.definePrototype({
	    enumerable: true
	}, {
	    type: 'operator'
	});

	OperatorToken.definePrototype({
	    TYPE_ID: Token.tokens.push(OperatorToken) - 1,
	    toArray: function () {
	        var _ = this;
	        return [
	            _.TYPE_ID,
	            _.operator,
	            _.operands
	        ];
	    },

	    toObject: function () {
	        var _ = this;
	        return {
	            type: _.type,
	            TYPE_ID: _.TYPE_ID,
	            operator: _.operator,
	            operands: _.operands
	        };
	    },

	    _fromArray: function _fromArray(arr) {
	        var _ = this;

	        _.operator = arr[1];

	        _.operands = arr[2].map(function (item) {
	            var arg = new Token.tokens[item[0]]();

	            arg.fromArray(item);

	            return arg;
	        });
	    },

	    toString: function toString() {
	        var _ = this,
	            str = '';

	        if (_.operands.length === 1) {
	            str += _.operator + _.operands[0].toString();
	        } else if (_.operands.length === 2) {
	            str += _.operands[0].toString();
	            str += ' ' + _.operator + ' ';
	            str += _.operands[1].toString();
	        }

	        return str;
	    }
	});

	Token.tokens.operator = OperatorToken;
	Token;


/***/ }),
/* 76 */
/***/ (function(module, exports, __webpack_require__) {

	var Token = __webpack_require__(56);

	var AssignmentToken = Token.generate(
	    function AssignmentToken(code) {
	        var _ = this;

	        if (code) {
	            Token.call(_, code);
	        }

	        _.name = '';

	        _.expression = null;
	    }
	);


	AssignmentToken.definePrototype({
	    enumerable: true
	}, {
	    type: 'assignment'
	});

	AssignmentToken.definePrototype({
	    TYPE_ID: Token.tokens.push(AssignmentToken) - 1,
	    toArray: function () {
	        var _ = this;
	        return [
	            _.TYPE_ID,
	            _.name,
	            _.expression
	        ];
	    },

	    toObject: function () {
	        var _ = this;
	        return {
	            type: _.type,
	            TYPE_ID: _.TYPE_ID,
	            name: _.name,
	            expression: _.expression
	        };
	    },

	    _fromArray: function _fromArray(arr) {
	        var _ = this;

	        _.name = arr[1];

	        _.expression = new Token.tokens[arr[2][0]]();

	        _.expression.fromArray(arr[2]);
	    },

	    toString: function toString() {
	        // var _ = this,
	        //     str = '';
	        //
	        // if (_.operands.length === 1) {
	        //     str += _.assignment + _.operands[0].toString();
	        // } else if (_.operands.length === 2) {
	        //     str += _.operands[0].toString();
	        //     str += ' ' + _.assignment + ' ';
	        //     str += _.operands[1].toString();
	        // }
	        //
	        // return str;
	    }
	});

	Token.tokens.assignment = AssignmentToken;


/***/ }),
/* 77 */
/***/ (function(module, exports, __webpack_require__) {

	var Generator = __webpack_require__(13);

	var Blocks = Generator.generate(function Blocks() {});

	Blocks.definePrototype({
	    if: function ifBlock(args, consequent, alternate, context) {
	        if (args[0]) {
	            consequent();
	        } else {
	            alternate();
	        }
	    },

	    with: function withBlock(args, consequent, alternate, context) {
	        var _ = this,
	            data = args[0];

	        if (!args.length) {
	            consequent();
	        } else if (data && typeof data === 'object') {
	            consequent(context.newContext(data));
	        } else {
	            alternate();
	        }
	    },

	    each: function eachBlock(args, consequent, alternate, context) {
	        var _ = this,
	            data = args[0];

	        if (data && typeof data === 'object') {
	            var keys = Object.keys(data);

	            if (keys.length) {
	                for (var i = 0; i < keys.length; i++) {
	                    consequent(
	                        context.newContext(
	                            data[keys[i]], {
	                                key: keys[i],
	                                index: i,
	                                length: keys.length
	                            }
	                        )
	                    );
	                }
	            } else {
	                alternate();
	            }
	        } else {
	            alternate();
	        }
	    }
	});

	module.exports = Blocks;


/***/ }),
/* 78 */
/***/ (function(module, exports, __webpack_require__) {

	var Generator = __webpack_require__(13);

	var Transform = Generator.generate(function Transform() {});

	Transform.definePrototype({
	    log: function log() {
	        var args = Array.prototype.slice.call(arguments);
	        args.unshift('Bars:');
	        console.log.apply(console, args);
	    },
	    upperCase: function upperCase(a) {
	        return String(a)
	            .toUpperCase();
	    },
	    lowerCase: function lowerCase(a) {
	        return String(a)
	            .toLowerCase();
	    },
	    number: function number(a) {
	        return Number(a);
	    },
	    string: function string(a) {
	        return String(a);
	    },
	    reverse: function reverse(arr) {
	        return arr.slice()
	            .reverse();
	    },
	    slice: function (arr, start, end) {
	        return arr.slice(start, end);
	    },
	    map: function map(arr, prop) {
	        return arr.map(function (item) {
	            return arr[prop];
	        });
	    },
	    sort: function sort(arr, key) {
	        return arr.slice()
	            .sort(function (a, b) {
	                if (key) {
	                    if (a[key] < b[key]) return -1;
	                    if (a[key] > b[key]) return 1;
	                    return 0;
	                }

	                if (a < b) return -1;
	                if (a > b) return 1;
	                return 0;
	            });
	    },
	    sum: function sum(arr, key) {
	        var sum = 0,
	            i;
	        if (key) {
	            for (i = 0; i < arr.length; i++) {
	                sum += arr[i][key];
	            }
	        } else {
	            for (i = 0; i < arr.length; i++) {
	                sum += arr[i];
	            }
	        }

	        return sum;
	    },
	    ave: function ave(arr, key) {
	        var sum = 0,
	            i;
	        if (key) {
	            for (i = 0; i < arr.length; i++) {
	                sum += arr[i][key];
	            }
	        } else {
	            for (i = 0; i < arr.length; i++) {
	                sum += arr[i];
	            }
	        }

	        return sum / arr.length;
	    }
	});

	module.exports = Transform;


/***/ }),
/* 79 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(80);


/***/ }),
/* 80 */
/***/ (function(module, exports, __webpack_require__) {

	var compileit = __webpack_require__(57);
	var parsers = __webpack_require__(81);

	var Token = __webpack_require__(55);

	/* Parse Modes */

	var parseModes = {
	    'TEXT': [
	        parsers.parseText,
	        parsers.parseBarsMarkup
	    ],
	    'BARS': [
	        parsers.parseBarsComment,
	        parsers.parseBarsBlock,
	        parsers.parseBarsPartial,
	        parsers.parseBarsInsert
	    ],
	    'DOM': [
	        parsers.parseText,
	        parsers.parseHTMLComment,
	        parsers.parseHTMLTag,
	        parsers.parseBarsMarkup
	    ],
	    'ATTR': [
	        parsers.parseHTMLTagEnd,
	        parsers.parseWhitspace,
	        parsers.parseHTMLAttr,
	        // parsers.parseBarsMarkup
	    ],
	    'VALUE': [
	        parsers.parseHTMLAttrEnd,
	        parsers.parseText,
	        parsers.parseBarsMarkup
	    ],
	    'LOGIC': [
	        parsers.parseBarsMarkupEnd,
	        parsers.parseExpressionLiteral,
	        parsers.parseExpressionTransform,
	        parsers.parseExpressionValue,
	        parsers.parseExpressionOperator,
	        parsers.parseExpressionAssignment,
	        parsers.parseWhitspace
	    ],
	    'LOGIC-EXP': [
	        parsers.parseBarsMarkupEnd,
	        parsers.parseExpressionLiteral,
	        parsers.parseExpressionTransform,
	        parsers.parseExpressionValue,
	        parsers.parseExpressionOperator,
	        parsers.parseWhitspace
	    ],
	    'LOGIC-ARGS': [
	        parsers.parseExpressionTransformEnd,
	        parsers.parseExpressionLiteral,
	        parsers.parseExpressionTransform,
	        parsers.parseExpressionValue,
	        parsers.parseExpressionOperator,
	        parsers.parseWhitspace
	    ]
	};

	var compiler = new compileit.Compiler(parseModes, {
	    modeFormater: function (a) {
	        return a.green;
	    },
	    charFormater: function (a) {
	        return a.green.underline;
	    },
	    funcFormater: function (a) {
	        return a.red;
	    },
	    typeFormater: function (a) {
	        return a.red;
	    },
	    sourceFormater: function (a) {
	        return ('`' + a + '`')
	            .green.underline;
	    }
	});

	function compile(str, file, mode, flags) {
	    mode = mode || 'DOM';
	    flags = flags || {};

	    var program = new Token.tokens.program(),
	        frag = new Token.tokens.fragment();

	    frag.nodesUpdate = 1;

	    program.mode = mode;
	    program.fragment = frag;

	    frag.nodes = compiler.compile(str, file, mode, flags);

	    return program;
	}

	module.exports = compile;


/***/ }),
/* 81 */
/***/ (function(module, exports, __webpack_require__) {

	// text
	exports.parseText = __webpack_require__(82);
	exports.parseWhitspace = __webpack_require__(86);

	// HTML markup
	exports.parseHTMLComment = __webpack_require__(87);
	exports.parseHTMLTag = __webpack_require__(88);
	exports.parseHTMLTagEnd = __webpack_require__(89);
	exports.parseHTMLAttr = __webpack_require__(90);
	exports.parseHTMLAttrEnd = __webpack_require__(91);

	// Bars markup
	exports.parseBarsMarkup = __webpack_require__(92);
	exports.parseBarsComment = __webpack_require__(93);
	exports.parseBarsInsert = __webpack_require__(94);
	exports.parseBarsPartial = __webpack_require__(95);
	exports.parseBarsBlock = __webpack_require__(96);
	exports.parseBarsMarkupEnd = __webpack_require__(97);

	// Expression
	exports.parseExpressionValue = __webpack_require__(98);
	exports.parseExpressionLiteral = __webpack_require__(99);
	exports.parseExpressionOperator = __webpack_require__(100);
	exports.parseExpressionAssignment = __webpack_require__(101);
	exports.parseExpressionTransform = __webpack_require__(102);
	exports.parseExpressionTransformEnd = __webpack_require__(103);


/***/ }),
/* 82 */
/***/ (function(module, exports, __webpack_require__) {

	var TextToken = __webpack_require__(55)
	    .tokens.text,
	    utils = __webpack_require__(83);

	function parseText(mode, code, tokens, flags, scope,
	    parseMode) {
	    var index = code.index,
	        isEntity = false,
	        entityStr = '',
	        value = '',
	        textExitTag;

	    if (mode === 'DOM') {
	        for (; index < code.length; index++) {
	            ch = code.codePointAt(index);

	            if (
	                ch === 0x003c /* < */ ||
	                ch === 0x007b /* { */ &&
	                code.codePointAt(index + 1) === 0x007b /* { */
	            ) {
	                value += entityStr;
	                break;
	            }

	            if (ch === 0x0026 /* & */ ) {
	                isEntity = true;
	                entityStr = code.charAt(index);

	                continue;
	            } else if (isEntity && ch === 0x003b /* ; */ ) {
	                entityStr += code.charAt(index);

	                value += utils.getHTMLUnEscape(entityStr);

	                isEntity = false;
	                entityStr = '';

	                continue;
	            }

	            if (isEntity && utils.isHTMLEntity(ch)) {
	                entityStr += code.charAt(index);
	            } else {
	                value += entityStr;
	                isEntity = false;
	                entityStr = '';

	                value += code.charAt(index);
	            }
	        }
	    } else if (flags.whitepaceString) {
	        for (; index < code.length; index++) {
	            ch = code.codePointAt(index);

	            /* \n */
	            if (ch === 0x000a) {
	                code.index = index;
	                return null;
	            }

	            if ( /* " but not \" */
	                ch === 0x0022 &&
	                code.codePointAt(index - 1) !== 0x005c
	            ) {
	                break;
	            }

	            if ( /* {{ */
	                ch === 0x007b &&
	                code.codePointAt(index + 1) === 0x007b
	            ) {
	                break;
	            }
	        }
	    } else {
	        for (; index < code.length; index++) {
	            if (
	                code.codePointAt(index) === 0x007b /* { */ &&
	                code.codePointAt(index + 1) === 0x007b /* { */
	            ) {
	                break;
	            } else if (
	                flags.textExitTag === 'script' &&
	                /* </script> */
	                code.codePointAt(index) === 0x003c &&
	                code.codePointAt(index + 1) === 0x002f &&

	                code.codePointAt(index + 2) === 0x0073 &&
	                code.codePointAt(index + 3) === 0x0063 &&
	                code.codePointAt(index + 4) === 0x0072 &&
	                code.codePointAt(index + 5) === 0x0069 &&
	                code.codePointAt(index + 6) === 0x0070 &&
	                code.codePointAt(index + 7) === 0x0074 &&

	                code.codePointAt(index + 8) === 0x003e
	            ) {
	                textExitTag = 9;
	                break;
	            } else if (
	                flags.textExitTag === 'style' &&
	                /* </style> */
	                code.codePointAt(index) === 0x003c &&
	                code.codePointAt(index + 1) === 0x002f &&

	                code.codePointAt(index + 2) === 0x0073 &&
	                code.codePointAt(index + 3) === 0x0074 &&
	                code.codePointAt(index + 4) === 0x0079 &&
	                code.codePointAt(index + 5) === 0x006c &&
	                code.codePointAt(index + 6) === 0x0065 &&

	                code.codePointAt(index + 7) === 0x003e
	            ) {
	                textExitTag = 8;
	                break;
	            }
	        }
	    }

	    if (code.index < index) {
	        var text = new TextToken(code);

	        code.index = index;

	        text.close();

	        if (flags.minify) {
	            text.value = utils.minifyHTMLText(value || text.source(code));
	            if (/^\s*$/.test(text.value))
	                return true;
	        } else {
	            text.value = value || text.source(code);
	        }

	        if (flags.textExitTag && textExitTag) {
	            code.index += textExitTag;
	            scope.close();
	            parseMode.close();
	        }

	        return text;
	    } else if (flags.textExitTag && textExitTag) {
	        code.index += textExitTag;
	        scope.close();
	        parseMode.close();
	    }

	    return null;
	}

	module.exports = parseText;


/***/ }),
/* 83 */
/***/ (function(module, exports, __webpack_require__) {

	var SELF_CLOSEING_TAGS = __webpack_require__(84);
	var ENTITIES = __webpack_require__(85);

	var Token = __webpack_require__(55),
	    AssignmentToken = Token.tokens.assignment,
	    LiteralToken = Token.tokens.literal,
	    ValueToken = Token.tokens.value,
	    OperatorToken = Token.tokens.operator;

	function pathSpliter(path) {
	    var splitPath;

	    if (path instanceof Array) {
	        splitPath = path;
	    } else if (typeof path === 'string') {
	        if (path.match(/[/]|[.][.]/)) {
	            splitPath = path.split('/');
	        } else {
	            splitPath = path.split('.');
	        }

	        if (!splitPath[0] && !splitPath[1]) {
	            splitPath = ['.'];
	        }

	        var barsProp = splitPath.pop()
	            .split('@');
	        if (barsProp[0]) {
	            splitPath.push(barsProp[0]);
	        }
	        if (barsProp[1]) {
	            splitPath.push('@' + barsProp[1]);
	        }
	    } else {
	        throw 'bad arrgument: expected String | Array<String>.';
	    }

	    return splitPath;
	}
	exports.pathSpliter = pathSpliter;

	function isSelfClosing(name) {
	    return SELF_CLOSEING_TAGS.indexOf(name) !== -1;
	}
	exports.isSelfClosing = isSelfClosing;

	function isHTMLIdentifierStart(ch) {
	    return (0x0041 <= ch && ch <= 0x005a) ||
	        (0x0061 <= ch && ch <= 0x007a);
	}
	exports.isHTMLIdentifierStart = isHTMLIdentifierStart;

	function isHTMLEntity(ch) {
	    /* ^[0-9A-Za-z]$ */
	    return (0x0030 <= ch && ch <= 0x0039) ||
	        (0x0041 <= ch && ch <= 0x005a) ||
	        (0x0061 <= ch && ch <= 0x007a);
	}
	exports.isHTMLEntity = isHTMLEntity;

	function isHTMLIdentifier(ch) {
	    /* ^[0-9A-Z_a-z-]$ */
	    return ch === 0x002d ||
	        (0x0030 <= ch && ch <= 0x0039) ||
	        (0x0041 <= ch && ch <= 0x005a) ||
	        ch === 0x005f ||
	        (0x0061 <= ch && ch <= 0x007a);
	}
	exports.isHTMLIdentifier = isHTMLIdentifier;


	function isWhitespace(ch) {
	    /* ^\s$ */
	    return (0x0009 <= ch && ch <= 0x000d) ||
	        ch === 0x0020 ||
	        ch === 0x00a0 || /* nbsp */
	        ch === 0x1680 ||
	        ch === 0x180e ||
	        (0x2000 <= ch && ch <= 0x200a) ||
	        (0x2028 <= ch && ch <= 0x2029) ||
	        ch === 0x202f ||
	        ch === 0x205f ||
	        ch === 0x3000 ||
	        ch === 0xfeff;
	}
	exports.isWhitespace = isWhitespace;

	function minifyHTMLText(text) {
	    return text.replace(/(\s*)/g, function ($1) {
	        return $1.split('')
	            .sort(function (a, b) {
	                a = a.codePointAt(0);
	                b = b.codePointAt(0);
	                if (a !== 0x00a0 && b === 0x00a0) return 1;
	                if (a === 0x00a0 && b !== 0x00a0) return -1;
	                return 0;
	            })
	            .join('')
	            .replace(/[^\u00a0]+/, ' ');
	    });
	}
	exports.minifyHTMLText = minifyHTMLText;

	function getHTMLUnEscape(str) {
	    var code;

	    code = ENTITIES[str.slice(1, -1)];

	    if (typeof code !== 'number' && str[1] === '#') {
	        code = parseInt(str.slice(2, -1), 0x000a);
	    }

	    if (typeof code === 'number' && !isNaN(code)) {
	        return String.fromCharCode(code);
	    }

	    return str;
	}

	exports.getHTMLUnEscape = getHTMLUnEscape;

	var OpPresidence = {
	    dm: ['/', '%', '*'],
	    as: ['+', '-'],
	    c: ['===', '==', '!==', '!=', '<=', '>=', '>', '<'],
	    ao: ['||', '&&'],
	    co: ['?:']
	};

	function lookupExpression(tokens, code) {
	    for (var i = 0; i < tokens.length; i++) {
	        prevToken = tokens[i - 1];
	        token = tokens[i];
	        nextToken = tokens[i + 1];
	        var dels = 3;

	        if (
	            OperatorToken.isCreation(token) &&
	            token.operator === '.' &&
	            !token.saturated
	        ) {
	            if (!OperatorToken.isCreation(prevToken) ||
	                prevToken.saturated
	            ) {
	                token.operands.unshift(prevToken);

	                if (token.operands.length === 1) {
	                    if (isName(nextToken)) {
	                        var lit = new LiteralToken(code);
	                        lit.range = nextToken.range;
	                        lit.loc = nextToken.loc;
	                        lit.value = nextToken.path[0];
	                        lit.closed = true;
	                        token.operands.push(lit);
	                    } else {
	                        throw code.makeError(
	                            token.range[0],
	                            token.range[2],
	                            'Unexpected token: ' +
	                            JSON.stringify(token.source())
	                            .slice(1, -1)
	                        );
	                    }
	                } else {
	                    dels = 2;
	                }
	            } else {
	                throw code.makeError(
	                    token.range[0],
	                    token.range[2],
	                    'Unexpected token: ' +
	                    JSON.stringify(token.source())
	                    .slice(1, -1)
	                );
	            }

	            token.saturated = true;
	            tokens.splice(Math.max(0, i - 1), dels, token);

	            i--;
	        }
	    }
	}

	function unaryExpression(tokens, code) {
	    for (var i = tokens.length - 1; i >= 0; i--) {
	        token = tokens[i];
	        nextToken = tokens[i + 1];

	        if (
	            OperatorToken.isCreation(token) &&
	            token.operator === '!'
	        ) {
	            if (!OperatorToken.isCreation(nextToken) ||
	                nextToken.saturated
	            ) {
	                token.operands.push(nextToken);
	            } else {
	                console.log(token);
	                throw code.makeError(
	                    token.range[0],
	                    token.range[2],
	                    'Unexpected token: ' +
	                    JSON.stringify(token.source())
	                    .slice(1, -1)
	                );
	            }

	            token.saturated = true;
	            tokens.splice(i, 2, token);
	        }
	    }
	}

	function binaryExpression(tokens, key, code) {
	    for (var i = 0; i < tokens.length; i++) {
	        prevToken = tokens[i - 1];
	        token = tokens[i];
	        nextToken = tokens[i + 1];
	        // console.log(
	        //     i, '\n',
	        //     prevToken && prevToken.constructor.name,
	        //     token && token.constructor.name,
	        //     nextToken && nextToken.constructor.name
	        // );

	        if (
	            OperatorToken.isCreation(token) &&
	            !token.saturated &&
	            OpPresidence[key].indexOf(token.operator) !== -1

	        ) {
	            if (!OperatorToken.isCreation(prevToken) ||
	                prevToken.saturated
	            ) {
	                token.operands.unshift(prevToken);

	                if (!OperatorToken.isCreation(nextToken) ||
	                    nextToken.saturated
	                ) {
	                    token.operands.push(nextToken);
	                } else {
	                    throw code.makeError(
	                        token.range[0],
	                        token.range[2],
	                        'Unexpected token: ' +
	                        JSON.stringify(token.source())
	                        .slice(1, -1)
	                    );
	                }
	            } else {
	                throw code.makeError(
	                    token.range[0],
	                    token.range[2],
	                    'Unexpected token: ' +
	                    JSON.stringify(token.source())
	                    .slice(1, -1)
	                );
	            }
	            token.saturated = true;
	            tokens.splice(i - 1, 3, token);
	            i--;
	        }
	    }
	}

	function makeExpressionTree(tokens, code) {
	    lookupExpression(tokens, code);
	    unaryExpression(tokens, code);

	    for (var key in OpPresidence) {
	        if (OpPresidence.hasOwnProperty(key)) {
	            binaryExpression(tokens, key, code);
	        }
	    }

	    // console.log(tokens[0], expressionTree(tokens[0]));

	    return tokens;
	}

	exports.makeExpressionTree = makeExpressionTree;

	function isName(token) {
	    return ValueToken.isCreation(token) &&
	        token.path.length === 1 &&
	        token.path[0] !== 'this' &&
	        token.path[0] !== '~' &&
	        token.path[0] !== '..' &&
	        token.path[0] !== '.' &&
	        token.path[0] !== '@';
	}

	function sortArgsAndContextMap(tokens, code) {
	    var i,
	        temp = [],
	        prevToken,
	        token,
	        nextToken;

	    for (i = 0; i < tokens.length; i++) {

	        prevToken = tokens[i - 1];
	        token = tokens[i];
	        nextToken = tokens[i + 1];

	        if (
	            AssignmentToken.isCreation(token)
	        ) {
	            if (isName(prevToken)) {
	                token.name = prevToken.path[0];

	                if (!AssignmentToken.isCreation(nextToken)) {
	                    token.expression = nextToken;
	                } else {
	                    throw code.makeError(
	                        token.range[0],
	                        token.range[2],
	                        'Unexpected token: ' +
	                        JSON.stringify(token.source())
	                        .slice(1, -1)
	                    );
	                }
	            } else {
	                throw code.makeError(
	                    token.range[0],
	                    token.range[2],
	                    'Unexpected token: ' +
	                    JSON.stringify(token.source())
	                    .slice(1, -1)
	                );
	            }

	            tokens.splice(i - 1, 3, token);
	        }
	    }

	    var map = [];
	    var args = [];

	    for (i = 0; i < tokens.length; i++) {
	        if (AssignmentToken.isCreation(tokens[i])) {
	            map.push(tokens[i]);
	        } else {
	            args.push(tokens[i]);
	        }
	    }

	    return {
	        args: args,
	        map: map
	    };
	}
	exports.sortArgsAndContextMap = sortArgsAndContextMap;


	function expressionTree(op, d) {
	    d = d || 0;

	    if (!op) return '';

	    var s = '';

	    s += (op.operator || op.value || op.name || op.path.join()) + '\n';

	    if (op.operator) {
	        d += 2;
	        var sp = (new Array(d + 1))
	            .join(' ');
	        s += sp;
	        s += expressionTree(op.operands[0], d);

	        if (op.operands[1]) {
	            s += sp;
	            s += expressionTree(op.operands[1], d);
	        }

	        if (op.operands[2]) {
	            s += sp;
	            s += expressionTree(op.operands[2], d);
	        }
	    }

	    return s;

	}


/***/ }),
/* 84 */
/***/ (function(module, exports) {

	module.exports = [
		"area",
		"base",
		"br",
		"col",
		"command",
		"embed",
		"hr",
		"img",
		"input",
		"keygen",
		"link",
		"meta",
		"param",
		"source",
		"track",
		"wbr"
	];

/***/ }),
/* 85 */
/***/ (function(module, exports) {

	module.exports = {
		"quot": 34,
		"amp": 38,
		"lt": 60,
		"gt": 62,
		"nbsp": 160,
		"iexcl": 161,
		"cent": 162,
		"pound": 163,
		"curren": 164,
		"yen": 165,
		"brvbar": 166,
		"sect": 167,
		"uml": 168,
		"copy": 169,
		"ordf": 170,
		"laquo": 171,
		"not": 172,
		"shy": 173,
		"reg": 174,
		"macr": 175,
		"deg": 176,
		"plusmn": 177,
		"sup2": 178,
		"sup3": 179,
		"acute": 180,
		"micro": 181,
		"para": 182,
		"middot": 183,
		"cedil": 184,
		"sup1": 185,
		"ordm": 186,
		"raquo": 187,
		"frac14": 188,
		"frac12": 189,
		"frac34": 190,
		"iquest": 191,
		"Agrave": 192,
		"Aacute": 193,
		"Acirc": 194,
		"Atilde": 195,
		"Auml": 196,
		"Aring": 197,
		"AElig": 198,
		"Ccedil": 199,
		"Egrave": 200,
		"Eacute": 201,
		"Ecirc": 202,
		"Euml": 203,
		"Igrave": 204,
		"Iacute": 205,
		"Icirc": 206,
		"Iuml": 207,
		"ETH": 208,
		"Ntilde": 209,
		"Ograve": 210,
		"Oacute": 211,
		"Ocirc": 212,
		"Otilde": 213,
		"Ouml": 214,
		"times": 215,
		"Oslash": 216,
		"Ugrave": 217,
		"Uacute": 218,
		"Ucirc": 219,
		"Uuml": 220,
		"Yacute": 221,
		"THORN": 222,
		"szlig": 223,
		"agrave": 224,
		"aacute": 225,
		"acirc": 226,
		"atilde": 227,
		"auml": 228,
		"aring": 229,
		"aelig": 230,
		"ccedil": 231,
		"egrave": 232,
		"eacute": 233,
		"ecirc": 234,
		"euml": 235,
		"igrave": 236,
		"iacute": 237,
		"icirc": 238,
		"iuml": 239,
		"eth": 240,
		"ntilde": 241,
		"ograve": 242,
		"oacute": 243,
		"ocirc": 244,
		"otilde": 245,
		"ouml": 246,
		"divide": 247,
		"oslash": 248,
		"ugrave": 249,
		"uacute": 250,
		"ucirc": 251,
		"uuml": 252,
		"yacute": 253,
		"thorn": 254,
		"euro": 8364
	};

/***/ }),
/* 86 */
/***/ (function(module, exports, __webpack_require__) {

	// parseWhitspace

	var utils = __webpack_require__(83);

	function parseWhitspace(mode, code, tokens, flags, scope, parseMode) {
	    var index = code.index,
	        length = code.length,
	        whitespace = 0;

	    for (; index < length; index++) {
	        if (!utils.isWhitespace(code.codePointAt(index))) {
	            break;
	        }
	        if (
	            flags.whitepaceString &&
	            code.codePointAt(index) === 0x000a /* \n */
	        ) {
	            break;
	        }
	        whitespace++;
	    }

	    if (whitespace) {
	        code.index = index;
	        return true;
	    }

	    return null;
	}

	module.exports = parseWhitspace;


/***/ }),
/* 87 */
/***/ (function(module, exports) {

	//parseHTMLComment

	function parseHTMLComment(mode, code, tokens, flags, scope, parseMode) {
	    var index = code.index,
	        length = code.length;

	    if ( /* <!-- */
	        code.codePointAt(index) === 0x003c &&
	        code.codePointAt(++index) === 0x0021 &&
	        code.codePointAt(++index) === 0x002d &&
	        code.codePointAt(++index) === 0x002d
	    ) {
	        index++;

	        for (; index < length; index++) {
	            if ( /* --> */
	                code.codePointAt(index) === 0x002d &&
	                code.codePointAt(index + 1) === 0x002d &&
	                code.codePointAt(index + 2) === 0x003e
	            ) {
	                index += 3;
	                code.index = index;

	                return true;
	            }
	        }

	        throw code.makeError(
	            code.index, code.index + 4,
	            'Unclosed Comment: Expected "-->" to fallow "<!--".'
	        );
	    }

	    return null;
	}

	module.exports = parseHTMLComment;


/***/ }),
/* 88 */
/***/ (function(module, exports, __webpack_require__) {

	var Token = __webpack_require__(55),
	    TagToken = Token.tokens.tag,
	    AttrToken = Token.tokens.attr,
	    PropToken = Token.tokens.prop,
	    utils = __webpack_require__(83);


	function parseHTMLTag(mode, code, tokens, flags, scope, parseMode) {
	    var index = code.index,
	        length = code.length,
	        tag,
	        isClosing;
	    if ( /* < */
	        code.codePointAt(index) === 0x003c
	    ) {
	        if ( /* / */
	            code.codePointAt(index + 1) === 0x002f
	        ) {
	            isClosing = true;
	            index++;
	        }

	        tag = new TagToken(code);

	        index++;

	        if (!utils.isHTMLIdentifierStart(code.codePointAt(index))) {
	            throw code.makeError(
	                index, index + 1,
	                'Unexpected Token: Expected <[A-Za-z]> but found ' +
	                JSON.stringify(code.charAt(index)) +
	                '.'
	            );
	        }

	        for (; index < length; index++) {
	            ch = code.codePointAt(index);

	            if (utils.isHTMLIdentifier(ch)) {
	                tag.name += code.charAt(index);
	            } else {
	                break;
	            }
	        }

	        code.index = index;

	        if (isClosing) {
	            if (ch !== 0x003e) { /* > */
	                throw code.makeError(
	                    index, index + 1,
	                    'Unexpected Token: Expected ' +
	                    JSON.stringify('>') +
	                    ' but found ' +
	                    JSON.stringify(code.charAt(index)) +
	                    '.'
	                );
	            }

	            index++;

	            code.index = index;
	            tag.close();

	            if (!TagToken.isCreation(scope.token)) {
	                throw code.makeError(
	                    tag.range[0], tag.range[1],
	                    'Unexpected Closing Tag: ' +
	                    JSON.stringify(tag.source(code)) +
	                    '.'
	                );
	            }

	            if (scope.token.name !== tag.name) {
	                throw code.makeError(
	                    tag.range[0], tag.range[1],
	                    'Mismatch Closing Tag: Expected ' +
	                    JSON.stringify('</' + scope.token.name + '>') +
	                    ' but found ' +
	                    JSON.stringify(tag.source(code)) +
	                    '.'
	                );
	            }

	            scope.close();
	            parseMode.close();

	            return true;
	        }

	        var attrsAndProps = [];

	        scope.push(tag);
	        parseMode('ATTR', attrsAndProps, flags);

	        tag.attrs = attrsAndProps.filter(function (token) {
	            return AttrToken.isCreation(token);
	        });

	        tag.props = attrsAndProps.filter(function (token) {
	            return PropToken.isCreation(token);
	        });

	        attrsAndProps = null;

	        if (!tag.closed) {
	            throw code.makeError(
	                index, index + 1,
	                'Unclosed Tag: Expected ' +
	                JSON.stringify('>') +
	                ' but found ' +
	                JSON.stringify(code.charAt(code.index)) +
	                '.'
	            );
	        }

	        if (utils.isSelfClosing(tag.name)) {
	            tag.selfClosing = true;
	        }

	        if (tag.selfClosing || tag.selfClosed) {
	            return tag;
	        }

	        delete tag.closed;

	        if (tag.name === 'pre' || tag.name === 'style' || tag.name ===
	            'script') {
	            flags.minify = false;
	        }

	        scope.push(tag);

	        if (tag.name === 'style' || tag.name === 'script') {
	            flags.textExitTag = tag.name;
	            parseMode('TEXT', tag.nodes, flags);
	            delete flags.textExitTag;
	        } else {
	            parseMode(mode, tag.nodes, flags);
	        }

	        if (!tag.closed) {
	            throw code.makeError(
	                tag.range[0], tag.range[1],
	                'Unclosed Tag: Expected ' +
	                JSON.stringify('</' + tag.name + '>') +
	                ' to fallow ' +
	                JSON.stringify(tag.source(code)) +
	                '.'
	            );
	        }

	        if (scope.token && (tag.attrsUpdate || tag.nodesUpdate)) {
	            scope.token.updates();
	        }

	        return tag;
	    }

	    return null;
	}


	module.exports = parseHTMLTag;


/***/ }),
/* 89 */
/***/ (function(module, exports) {

	// parseHTMLTagEnd

	function parseHTMLTagEnd(mode, code, tokens, flags, scope, parseMode) {
	    var ch = code.codePointAt(code.index);
	    /* > */
	    if (ch === 0x003e) {
	        code.index++;
	        scope.close();

	        parseMode.close();
	        return true;
	    } else if ( /* /> */
	        ch === 0x002f &&
	        code.codePointAt(code.index + 1) === 0x003e
	    ) {
	        code.index += 2;
	        var tag = scope.close();
	        tag.selfClosed = true;

	        parseMode.close();
	        return true;
	    }

	    return null;
	}

	module.exports = parseHTMLTagEnd;


/***/ }),
/* 90 */
/***/ (function(module, exports, __webpack_require__) {

	// parseHTMLAttr
	var Token = __webpack_require__(55),
	    AttrToken = Token.tokens.attr,
	    PropToken = Token.tokens.prop,
	    utils = __webpack_require__(83);

	function parseHTMLAttr(mode, code, tokens, flags, scope, parseMode) {
	    var index = code.index,
	        length = code.length,
	        attr;

	    if (!utils.isHTMLIdentifierStart(code.codePointAt(index))) {
	        return null;
	    }

	    attr = new AttrToken(code);
	    prop = new PropToken(code);

	    for (; index < length; index++) {

	        if (!utils.isHTMLIdentifier(code.codePointAt(index))) {
	            break;
	        }

	        attr.name += code.charAt(index);
	    }

	    prop.name = attr.name;

	    if (attr.name) {
	        /* = */
	        if (code.codePointAt(index) === 0x003d) {
	            index++;
	            /* " */
	            if (code.codePointAt(index) === 0x0022) {
	                index++;
	                code.index = index;

	                scope.push(attr);
	                flags.whitepaceString = true;
	                parseMode('VALUE', attr.nodes, flags);
	                delete flags.whitepaceString;
	            } else {
	                throw code.makeError(
	                    index, index + 1,
	                    'Unexpected Token: Expected "\"" but found ' +
	                    JSON.stringify(code.charAt(index))
	                );
	            }
	        } else if (code.codePointAt(index) === 0x003a) { /* : */
	            index++;
	            if ( /* {{ */
	                code.codePointAt(index) === 0x007b &&
	                code.codePointAt(index + 1) === 0x007b
	            ) {
	                var args = [];
	                code.index = index + 2;
	                scope.push(prop);
	                parseMode('LOGIC-EXP', args, flags);

	                args = utils.makeExpressionTree(args, code);

	                if (args.length > 1) {
	                    code.index = args[1].range[0];
	                    throw code.makeError(
	                        args[1].range[0], args[1].range[1],
	                        'Unexpected Token: ' +
	                        JSON.stringify(args[1].source(code)) + '.'
	                    );
	                }

	                prop.expression = args[0];

	                args = null;

	                if (!prop.closed) {
	                    throw code.makeError(
	                        code.index, code.index + 1,
	                        'Unclosed Block: Expected ' +
	                        JSON.stringify('}}') +
	                        ' but found ' +
	                        JSON.stringify(code.charAt(code.index)) +
	                        '.'
	                    );
	                }

	                if (!prop.expression) {
	                    throw code.makeError(
	                        code.index - 2, code.index - 1,
	                        'Missing <expression>.'
	                    );
	                }

	                return prop;

	            } else {
	                throw code.makeError(
	                    index - 1, index,
	                    'Unexpected Token: :'
	                );
	            }
	        } else {
	            code.index = index;
	            attr.close();
	        }

	        if (!attr.closed) {
	            throw code.makeError(
	                attr.range[0] + attr.name.length + 1,
	                attr.range[0] + attr.name.length + 2,
	                'Unclosed String: Expected "\"" to fallow "\""'
	            );
	        }

	        if (scope.token && attr.nodesUpdate) {
	            scope.token.updates('attr');
	        }

	        return attr;
	    }

	    return null;
	}

	module.exports = parseHTMLAttr;


/***/ }),
/* 91 */
/***/ (function(module, exports) {

	//parseHTMLAttrEnd

	function parseHTMLAttrEnd(mode, code, tokens, flags, scope, parseMode) {
	    if (code.codePointAt(code.index) === 0x0022 /* " */ ) {
	        code.index++;

	        scope.close();
	        parseMode.close();

	        return true;
	    }

	    return null;
	}

	module.exports = parseHTMLAttrEnd;


/***/ }),
/* 92 */
/***/ (function(module, exports) {

	//parseBarsMarkup

	function parseBarsMarkup(mode, code, tokens, flags, scope, parseMode) {
	    var index = code.index,
	        length = code.length;

	    if ( /* {{ */
	        code.codePointAt(index) === 0x007b &&
	        code.codePointAt(++index) === 0x007b
	    ) {
	        flags.markup = {};
	        flags.markup.mode = mode;
	        parseMode('BARS', tokens, flags);

	        if (code.index > index) {
	            if (flags.markup && flags.markup.closeParseScope) {
	                parseMode.close();
	            }
	            delete flags.markup;
	            if (scope.token) {
	                scope.token.updates();
	            }
	            return true;
	        }

	        delete flags.markup;
	    }

	    return null;
	}

	module.exports = parseBarsMarkup;


/***/ }),
/* 93 */
/***/ (function(module, exports) {

	//parseBarsComment

	function parseBarsComment(mode, code, tokens, flags, scope, parseMode) {
	    var index = code.index + 2,
	        length = code.length;

	    if ( /* ! */
	        code.codePointAt(index) === 0x0021
	    ) {
	        if (
	            code.codePointAt(++index) === 0x002d &&
	            code.codePointAt(++index) === 0x002d
	        ) {
	            index++;

	            for (; index < length; index++) {
	                if ( /* --}} */
	                    code.codePointAt(index) === 0x002d &&
	                    code.codePointAt(index + 1) === 0x002d &&
	                    code.codePointAt(index + 2) === 0x007d &&
	                    code.codePointAt(index + 3) === 0x007d
	                ) {
	                    index += 4; /* for --}} */
	                    code.index = index;

	                    parseMode.close();

	                    if (flags.keepComments) {
	                        // make a CommentToken and return that.
	                    }

	                    return true;
	                }
	            }

	            throw code.makeError(
	                'Unclosed Comment: Expected "--}}" to fallow "{{!--".',
	                5
	            );
	        }

	        index++;

	        for (; index < length; index++) {

	            if ( /* }} */
	                code.codePointAt(index) === 0x007d &&
	                code.codePointAt(index + 1) === 0x007d
	            ) {
	                index += 2; /* for }} */
	                code.index = index;

	                parseMode.close();

	                if (flags.keepComments) {
	                    // make a CommentToken and return that.
	                }

	                return true;
	            }
	        }

	        throw code.makeError(
	            code.index, code.index + 3,
	            'Unclosed Comment: Expected "}}" to fallow "{{!".'
	        );
	    }

	    return null;
	}

	module.exports = parseBarsComment;


/***/ }),
/* 94 */
/***/ (function(module, exports, __webpack_require__) {

	var InsertToken = __webpack_require__(55)
	    .tokens.insert,
	    utils = __webpack_require__(83);

	function parseBarsInsert(mode, code, tokens, flags, scope, parseMode) {
	    var index = code.index + 2,
	        length = code.length,
	        insert = new InsertToken(code),
	        args = [];

	    scope.push(insert);
	    code.index = index;

	    parseMode('LOGIC-EXP', args, flags);

	    args = utils.makeExpressionTree(args, code);

	    if (args.length > 1) {
	        code.index = args[1].range[0];
	        throw code.makeError(
	            args[1].range[0], args[1].range[1],
	            'Unexpected Token: ' +
	            JSON.stringify(args[1].source(code)) + '.'
	        );
	    }

	    insert.expression = args[0];

	    args = null;

	    if (!insert.closed) {
	        throw code.makeError(
	            code.index, code.index + 1,
	            'Unclosed Block: Expected ' +
	            JSON.stringify('}}') +
	            ' but found ' +
	            JSON.stringify(code.charAt(code.index)) +
	            '.'
	        );
	    }

	    if (!insert.expression) {
	        throw code.makeError(
	            code.index - 2, code.index - 1,
	            'Missing <expression>.'
	        );
	    }

	    parseMode.close();
	    return insert;
	}


	module.exports = parseBarsInsert;


/***/ }),
/* 95 */
/***/ (function(module, exports, __webpack_require__) {

	var PartialToken = __webpack_require__(55)
	    .tokens.partial,
	    utils = __webpack_require__(83);

	function parseBarsPartial(mode, code, tokens, flags, scope, parseMode) {
	    var index = code.index + 2,
	        length = code.length,
	        partial,
	        router = false;

	    if ( /* > */
	        code.codePointAt(index) === 0x003e
	    ) {
	        partial = new PartialToken(code);

	        index++;

	        if (code.codePointAt(index) === 0x003f) {
	            router = true;
	            index++;
	        } else if (utils.isHTMLIdentifierStart(code.codePointAt(index))) {
	            for (; index < length; index++) {
	                ch = code.codePointAt(index);

	                if (utils.isHTMLIdentifier(ch)) {
	                    partial.name += code.charAt(index);
	                } else {
	                    break;
	                }
	            }
	        } else {
	            throw code.makeError(
	                index, index + 1,
	                'Unexpected Token: Expected <[A-Za-z]> but found ' +
	                JSON.stringify(code.charAt(index)) +
	                '.'
	            );
	        }

	        code.index = index;

	        var args = [];

	        scope.push(partial);
	        parseMode('LOGIC', args, flags);

	        args = utils.makeExpressionTree(args, code);

	        var am = utils.sortArgsAndContextMap(args, code);
	        args = am.args;
	        partial.map = am.map;

	        am = null;

	        if (args.length > (router ? 2 : 1)) {
	            throw code.makeError(
	                args[1].range[0], args[1].range[1],
	                'Unexpected Token: ' +
	                JSON.stringify(args[1].source(code)) + '.'
	            );
	        }

	        if (router) {
	            partial.name = args[0] || null;
	            partial.expression = args[1] || null;
	        } else {
	            partial.expression = args[0] || null;
	        }

	        args = null;

	        if (!partial.closed) {
	            throw code.makeError(
	                index, index + 1,
	                'Unclosed Block: Expected ' +
	                JSON.stringify('}}') +
	                ' but found ' +
	                JSON.stringify(code.charAt(code.index)) +
	                '.'
	            );
	        }

	        parseMode.close();
	        return partial;
	    }

	    return null;
	}

	module.exports = parseBarsPartial;


/***/ }),
/* 96 */
/***/ (function(module, exports, __webpack_require__) {

	var Token = __webpack_require__(55),
	    BlockToken = Token.tokens.block,
	    FragmentToken = Token.tokens.fragment,
	    utils = __webpack_require__(83);

	function parseBarsBlock(mode, code, tokens, flags, scope, parseMode) {
	    var index = code.index + 2,
	        length = code.length,
	        block,
	        isOpening,
	        isClosing,
	        isElse,
	        alternateIsBlock,
	        blockMode = flags.markup.mode;

	    if ( /* / */
	        code.codePointAt(index) === 0x002f
	    ) {
	        isClosing = true;
	        flags.markup.closeParseScope = true;
	    } else if ( /* # */
	        code.codePointAt(index) === 0x0023 ||
	        (scope.token && scope.token.alternateIsBlock)
	    ) {
	        isOpening = true;
	    } else if ( /* else */
	        code.codePointAt(index) === 0x0065 &&
	        code.codePointAt(++index) === 0x006c &&
	        code.codePointAt(++index) === 0x0073 &&
	        code.codePointAt(++index) === 0x0065
	    ) {
	        isElse = true;
	        if (utils.isWhitespace(code.codePointAt(index + 1))) {
	            index += 2;

	            alternateIsBlock = true;
	        } else if (
	            code.codePointAt(++index) === 0x007d &&
	            code.codePointAt(++index) === 0x007d
	        ) {
	            index++;
	        }

	        block = new BlockToken(code);
	        code.index = index;
	        block.close();

	        if (!BlockToken.isCreation(scope.token) || scope.token.elsed) {
	            throw code.makeError(
	                block.range[0], block.range[1],
	                'Unexpected Token: ' +
	                JSON.stringify(block.source(code)) +
	                '.'
	            );
	        }

	        scope.token.elsed = true;

	        scope.token.alternateIsBlock = alternateIsBlock;
	        flags.markup.closeParseScope = true;

	        scope.close();
	        parseMode.close();

	        return true;
	    } else {
	        return null;
	    }

	    if (scope.token && scope.token.alternateIsBlock) {
	        index -= 2;
	    } else
	        index++;
	    block = new BlockToken(code);

	    if (!utils.isHTMLIdentifierStart(code.codePointAt(index))) {
	        throw code.makeError(
	            index, index + 1,
	            'Unexpected Token: Expected <[A-Za-z]> but found ' +
	            JSON.stringify(code.charAt(index)) +
	            '.'
	        );
	    }

	    for (; index < length; index++) {
	        ch = code.codePointAt(index);

	        if (utils.isHTMLIdentifier(ch)) {
	            block.name += code.charAt(index);
	        } else {
	            break;
	        }
	    }

	    if (isClosing) {
	        if (
	            code.codePointAt(index) === 0x007d &&
	            code.codePointAt(++index) === 0x007d
	        ) {
	            index++;
	        } else {
	            throw code.makeError(
	                index, index + 1,
	                'Unexpected Token: Expected ' +
	                JSON.stringify('}}') +
	                ' but found ' +
	                JSON.stringify(code.charAt(index)) +
	                '.'
	            );
	        }

	        code.index = index;
	        block.close();

	        if (!BlockToken.isCreation(scope.token)) {
	            throw code.makeError(
	                block.range[0], block.range[1],
	                'Unexpected Closing Block: ' +
	                JSON.stringify(block.source(code)) +
	                '.'
	            );
	        }

	        if (scope.token.name !== block.name) {
	            throw code.makeError(
	                block.range[0], block.range[1],
	                'Mismatch Closing Block: Expected ' +
	                JSON.stringify('{{/' + scope.token.name + '}}') +
	                ' but found ' +
	                JSON.stringify(block.source(code)) +
	                '.'
	            );
	        }

	        scope.close();

	        parseMode.close();

	        return true;
	    }

	    if (utils.isWhitespace(code.codePointAt(index)))
	        index++;

	    code.index = index;

	    var args = [];

	    scope.push(block);

	    parseMode('LOGIC', args, flags);

	    args = utils.makeExpressionTree(args, code);

	    var am = utils.sortArgsAndContextMap(args, code);

	    block.map = am.map;
	    block.arguments = am.args;

	    args = null;
	    am = null;

	    if (!block.closed) {
	        throw code.makeError(
	            code.index, code.index + 1,
	            'Unclosed Block: Expected ' +
	            JSON.stringify('}}') +
	            ' but found ' +
	            JSON.stringify(code.charAt(code.index)) +
	            '.'
	        );
	    }

	    block.consequent = new FragmentToken(code);

	    delete block.closed;
	    scope.push(block);

	    parseMode(blockMode, block.consequent.nodes, flags);

	    index = code.index;

	    block.consequent.close();

	    code.index = index;

	    if (block.elsed) {
	        if (block.alternateIsBlock) {
	            delete block.closed;
	            scope.push(block);

	            flags.markup = {
	                mode: blockMode
	            };
	            block.alternate = parseBarsBlock(mode, code, [], flags, scope,
	                parseMode);

	            delete flags.markup;

	            scope.close();

	            return block;
	        }

	        block.alternate = new FragmentToken(code);

	        delete block.closed;
	        scope.push(block);

	        parseMode(blockMode, block.alternate.nodes, flags);

	        index = code.index;

	        block.alternate.close();
	    }

	    if (!block.closed) {
	        throw code.makeError(
	            block.range[0], block.range[0] + block.name.length + 6 +
	            block.expression.length,
	            'Unclosed Block: Expected ' +
	            JSON.stringify('{{/' + block.name + '}}') +
	            ' to fallow ' +
	            JSON.stringify('{{#' + block.name + ' <expression>}}') +
	            '.'
	        );
	    }

	    parseMode.close();

	    return block;
	}

	module.exports = parseBarsBlock;


/***/ }),
/* 97 */
/***/ (function(module, exports, __webpack_require__) {

	// parseBarsMarkupEnd
	var Token = __webpack_require__(55);

	function parseBarsMarkupEnd(mode, code, tokens, flags, scope, parseMode) {
	    if ( /* }} */
	        code.codePointAt(code.index) === 0x007d &&
	        code.codePointAt(code.index + 1) === 0x007d
	    ) {
	        // console.log(JSON.stringify(scope.token.toObject(), null, 2))
	        if (
	            Token.tokens.insert.isCreation(scope.token) ||
	            Token.tokens.block.isCreation(scope.token) ||
	            Token.tokens.partial.isCreation(scope.token) ||
	            Token.tokens.prop.isCreation(scope.token)
	        ) {
	            code.index += 2;
	            scope.close();
	            parseMode.close();
	            return true;
	        }
	    }

	    return null;
	}

	module.exports = parseBarsMarkupEnd;


/***/ }),
/* 98 */
/***/ (function(module, exports, __webpack_require__) {

	var Token = __webpack_require__(55),
	    ValueToken = Token.tokens.value,
	    OperatorToken = Token.tokens.operator,
	    utils = __webpack_require__(83);

	function parseExpressionValue(mode, code, tokens, flags, scope, parseMode) {
	    var index = code.index,
	        length = code.length,
	        ch = code.codePointAt(index),
	        prop = ch === 0x0040;

	    if (!utils.isHTMLIdentifierStart(ch) &&
	        !prop
	    ) {
	        return null;
	    }

	    value = new ValueToken(code);

	    value.path = [];

	    if (prop) {
	        value.path.push('@');
	        index++;
	    }

	    var name = '';

	    for (; index < length; index++) {
	        ch = code.codePointAt(index);

	        if (utils.isHTMLIdentifier(ch)) {
	            name += code.charAt(index);
	        } else {
	            break;
	        }
	    }

	    if (!name) {
	        throw code.makeError(
	            value.range[0], value.range[1],
	            'Unexpected Token: ' +
	            JSON.stringify(value.source())
	            .slice(1, -1)
	        );
	    }

	    value.path.push(name);
	    code.index = index;
	    value.close();

	    return value;
	}

	module.exports = parseExpressionValue;


/***/ }),
/* 99 */
/***/ (function(module, exports, __webpack_require__) {

	var Token = __webpack_require__(55),
	    LiteralToken = Token.tokens.literal,
	    OperatorToken = Token.tokens.operator;

	function STRING(mode, code, tokens, flags, scope, parseMode) {
	    var ch,
	        index = code.index,
	        length = code.length,
	        text;

	    /* ' */
	    if (code.codePointAt(index) !== 0x0027) {
	        return null;
	    }

	    index++;

	    text = new LiteralToken(code);
	    text.value = '';

	    for (; index < length; index++) {
	        ch = code.codePointAt(index);

	        if (ch === 0x000a) {
	            code.index = index;
	            return null;
	        }

	        if ( /* ' but not \' */
	            ch === 0x0027 &&
	            code.codePointAt(index - 1) !== 0x005c
	        ) {
	            index++;
	            break;
	        }

	        text.value += code.charAt(index);
	    }

	    if (index > code.index) {
	        code.index = index;
	        text.close();

	        return text;
	    }

	    return null;
	}

	function NUMBER(mode, code, tokens, flags, scope, parseMode) {
	    var index = code.index,
	        length = code.length,
	        ch = code.codePointAt(index),
	        nextCh = code.codePointAt(index + 1),
	        dot,
	        Ee;

	    if (
	        (ch === 0x002d && 0x0030 <= nextCh && nextCh <= 0x0039) || /* -[0-9] */
	        (0x0030 <= ch && ch <= 0x0039) /* [0-9] */
	    ) {
	        index++;

	        number = new LiteralToken(code);

	        for (; index < length; index++) {
	            ch = code.codePointAt(index);

	            if (0x0030 <= ch && ch <= 0x0039) {
	                continue;
	            } else if (ch === 0x0045 || ch === 0x0065) { /* [Ee] */
	                index++;

	                ch = code.codePointAt(index);
	                nextCh = code.codePointAt(index + 1);

	                if ( /* [+-]?[0-9] */
	                    Ee ||
	                    !(
	                        (
	                            (ch === 0x002b || ch === 0x002d) &&
	                            (0x0030 <= nextCh && nextCh <= 0x0039)
	                        ) ||
	                        (0x0030 <= ch && ch <= 0x0039)
	                    )
	                ) {
	                    code.index = index - 1;
	                    throw code.makeError(
	                        'Unexpected Token: ' +
	                        JSON.stringify(code.charAt(index - 1)) +
	                        '.'
	                    );
	                }

	                Ee = true;
	            } else if (ch === 0x002e) { /* . */
	                index++;
	                ch = code.codePointAt(index);
	                if ( /* [+-]?[0-9] */
	                    Ee ||
	                    dot ||
	                    !(0x0030 <= ch && ch <= 0x0039)
	                ) {
	                    code.index = index - 1;
	                    throw code.makeError(
	                        'Unexpected Token: ".".'
	                    );
	                }

	                dot = true;
	            } else {
	                break;
	            }
	        }
	        code.index = index;
	        number.close();
	        number.value = Number(number.source(code));

	        return number;
	    }

	    return null;
	}

	function BOOLEAN(mode, code, tokens, flags, scope, parseMode) {
	    var index = code.index,
	        bool;

	    if ( /* true */
	        code.codePointAt(index) === 0x0074 &&
	        code.codePointAt(++index) === 0x0072 &&
	        code.codePointAt(++index) === 0x0075 &&
	        code.codePointAt(++index) === 0x0065
	    ) {
	        bool = true;
	    } else if ( /* false */
	        code.codePointAt(index) === 0x0066 &&
	        code.codePointAt(++index) === 0x0061 &&
	        code.codePointAt(++index) === 0x006c &&
	        code.codePointAt(++index) === 0x0073 &&
	        code.codePointAt(++index) === 0x0065
	    ) {
	        bool = false;
	    } else {
	        return null;
	    }

	    var boolean = new LiteralToken(code);

	    index++;
	    code.index = index;
	    boolean.close();

	    boolean.value = bool;

	    return boolean;
	}

	function NULL(mode, code, tokens, flags, scope, parseMode) {
	    var index = code.index,
	        nul;

	    if ( /* true */
	        code.codePointAt(index) === 0x006e &&
	        code.codePointAt(++index) === 0x0075 &&
	        code.codePointAt(++index) === 0x006c &&
	        code.codePointAt(++index) === 0x006c
	    ) {
	        index++;

	        nul = new LiteralToken(code);
	        code.index = index;
	        nul.close();
	        nul.value = null;
	    } else {
	        return null;
	    }

	    return nul;
	}


	function parseExpressionLiteral(mode, code, tokens, flags, scope, parseMode) {
	    return (
	        STRING(mode, code, tokens, flags, scope, parseMode) ||
	        NUMBER(mode, code, tokens, flags, scope, parseMode) ||
	        BOOLEAN(mode, code, tokens, flags, scope, parseMode) ||
	        NULL(mode, code, tokens, flags, scope, parseMode)
	    );
	}

	module.exports = parseExpressionLiteral;


/***/ }),
/* 100 */
/***/ (function(module, exports, __webpack_require__) {

	var compileit = __webpack_require__(57),
	    Token = __webpack_require__(55),
	    OperatorToken = Token.tokens.operator,
	    AssignmentToken = Token.tokens.assignment,
	    utils = __webpack_require__(83);

	function opS(ch) {
	    return ch === 0x0021 ||
	        (0x0025 <= ch && ch <= 0x0026) ||
	        (0x002a <= ch && ch <= 0x002b) ||
	        (0x002d <= ch && ch <= 0x002f) ||
	        (0x003c <= ch && ch <= 0x003e) ||
	        ch === 0x007c;
	}

	function opEQ(ch) {
	    return ch === 0x0021 ||
	        (0x003c <= ch && ch <= 0x003e);
	}

	function opEQEQ(ch) {
	    return ch === 0x0021 ||
	        ch === 0x003d;
	}

	function isEQ(ch) {
	    return ch === 0x003d;
	}

	function isOR(ch) {
	    return ch === 0x007c;
	}

	function isAND(ch) {
	    return ch === 0x0026;
	}

	function parseConditional(mode, code, tokens, flags, scope, parseMode) {
	    var index = code.index,
	        length = code.length,
	        operator,
	        args;

	    if (
	        code.codePointAt(index) === 0x003f // ^[?]$
	    ) {
	        operator = new OperatorToken(code);
	        code.index++;

	        operator.operator = '?:';

	        args = [];
	        scope.push(operator);

	        parseMode('LOGIC-EXP', args, flags);
	        // do more here

	        args = utils.makeExpressionTree(args, code);

	        if (args.length > 1) throw 'OPERATOR OPERAND MISMATCH';

	        operator.operands.push(args[0]);

	        return operator;
	    } else if (
	        code.codePointAt(index) === 0x003a // ^[:]$
	    ) {
	        if (
	            OperatorToken.isCreation(scope.token) &&
	            scope.token.operator === '?:'
	        ) {
	            code.index++;
	            scope.close();
	            parseMode.close();
	            return true;
	        } else {
	            throw code.makeError(
	                index,
	                index + 1,
	                'Unexpected token: ' + code.charAt(index)
	            );
	        }
	    }

	    return null;
	}

	function parseParentheses(mode, code, tokens, flags, scope, parseMode) {
	    var index = code.index,
	        length = code.length,
	        operator,
	        args,
	        p, b;

	    if (
	        (p = code.codePointAt(index) === 0x0028) || // ^[(]$
	        (b = code.codePointAt(index) === 0x005b) // ^[\[]$
	    ) {
	        operator = new OperatorToken(code);
	        code.index++;

	        if (p) {
	            operator.parentheses = true;
	        } else if (b) {
	            operator.brackets = true;
	        }

	        operator.operator = '.';

	        args = [];
	        scope.push(operator);

	        parseMode('LOGIC-EXP', args, flags);
	        // do more here

	        args = utils.makeExpressionTree(args, code);

	        if (args.length > 1) throw 'OPERATOR OPERAND MISMATCH';

	        operator.operands.push(args[0]);

	        if (p) {
	            return args[0];
	        } else if (b) {
	            return operator;
	        }
	    } else if (
	        (p = code.codePointAt(index) === 0x0029) || // ^[)]$
	        (b = code.codePointAt(index) === 0x005d) // ^[\]]$
	    ) {
	        if (
	            OperatorToken.isCreation(scope.token) &&
	            (
	                (p && scope.token.parentheses) ||
	                (b && scope.token.brackets)
	            )
	        ) {
	            code.index++;
	            scope.close();
	            parseMode.close();
	            return true;
	        } else {
	            throw code.makeError(
	                index,
	                index + 1,
	                'Unexpected token: ' + code.charAt(index)
	            );
	        }
	    }

	    return null;
	}

	function parseOperator(mode, code, tokens, flags, scope, parseMode) {
	    var index = code.index,
	        length = code.length,
	        ch = code.codePointAt(index);

	    if (!opS(ch)) {
	        return null;
	    }

	    var operator = new OperatorToken(code);

	    if (opEQ(ch) && isEQ(code.codePointAt(index + 1))) {
	        index++;
	    } else if (isEQ(ch)) {
	        return null;
	    }

	    if (
	        (isOR(ch) && isOR(code.codePointAt(index + 1))) ||
	        (isAND(ch) && isAND(code.codePointAt(index + 1)))
	    ) {
	        index++;
	    } else if (isOR(ch) || isAND(ch)) {
	        throw code.makeError(
	            operator.range[0],
	            operator.range[1],
	            'Unexpected token: ' +
	            JSON.stringify(
	                operator.source()
	            )
	            .slice(1, -1)
	        );
	    }

	    if (opEQEQ(ch) && isEQ(code.codePointAt(index + 1))) {
	        index++;
	    }
	    index++;

	    code.index = index;

	    operator.close();
	    operator.operator = operator.source();
	    var preToken = tokens[tokens.length - 1];
	    var pre2Token = tokens[tokens.length - 2];
	    if (
	        AssignmentToken.isCreation(preToken) ||
	        (
	            operator.operator !== '!' &&
	            (!preToken ||
	                (!preToken.saturated &&
	                    !preToken.brackets &&
	                    OperatorToken.isCreation(preToken)
	                )
	            )
	        ) ||
	        (
	            OperatorToken.isCreation(preToken) &&
	            preToken.operator === '!' &&
	            OperatorToken.isCreation(pre2Token) &&
	            pre2Token.operator === '!'
	        )
	    ) {
	        throw code.makeError(
	            operator.range[0],
	            operator.range[1],
	            'Unexpected token: ' +
	            JSON.stringify(
	                operator.source()
	            )
	            .slice(1, -1)
	        );
	    }

	    return operator;
	}

	function parseExpressionOperator(mode, code, tokens, flags, scope, parseMode) {
	    return (
	        parseOperator(mode, code, tokens, flags, scope, parseMode) ||
	        parseParentheses(mode, code, tokens, flags, scope, parseMode) ||
	        parseConditional(mode, code, tokens, flags, scope, parseMode)
	    );
	}

	module.exports = parseExpressionOperator;


/***/ }),
/* 101 */
/***/ (function(module, exports, __webpack_require__) {

	var Token = __webpack_require__(55),
	    ValueToken = Token.tokens.value,
	    AssignmentToken = Token.tokens.assignment;

	function isEQ(ch) {
	    return ch === 0x003d;
	}

	function parseAssignment(mode, code, tokens, flags, scope, parseMode) {
	    var index = code.index,
	        length = code.length;

	    if (!isEQ(code.codePointAt(index))) {
	        return null;
	    }

	    var assignment = new AssignmentToken(code);

	    code.index++;

	    assignment.close();

	    var preToken = tokens[tokens.length - 1];

	    if (!ValueToken.isCreation(preToken)) {
	        throw code.makeError(
	            assignment.range[0],
	            assignment.range[1],
	            'Unexpected Token: ' +
	            JSON.stringify(
	                assignment.source()
	            )
	            .slice(1, -1)
	        );

	    }

	    return assignment;
	}

	module.exports = parseAssignment;


/***/ }),
/* 102 */
/***/ (function(module, exports, __webpack_require__) {

	var Token = __webpack_require__(55),
	    TransformToken = Token.tokens.transform,
	    OperatorToken = Token.tokens.operator,
	    utils = __webpack_require__(83);

	function parseExpressionTransform(mode, code, tokens, flags, scope, parseMode) {
	    var index = code.index,
	        length = code.length,
	        transform,
	        ch = code.codePointAt(index);

	    if (ch !== 0x0040) { /* @ */
	        return null;
	    }

	    index++;

	    if (!utils.isHTMLIdentifierStart(code.codePointAt(index))) {
	        return null;
	    }

	    transform = new TransformToken(code);

	    for (; index < length; index++) {
	        ch = code.codePointAt(index);

	        if (utils.isHTMLIdentifier(ch)) {
	            transform.name += code.charAt(index);
	        } else {
	            break;
	        }
	    }

	    ch = code.codePointAt(index);
	    if (ch === 0x0028) { /* ( */
	        index++;
	        code.index = index;

	        scope.push(transform);

	        while (code.left) {
	            var args = [];


	            parseMode('LOGIC-ARGS', args, flags);

	            args = utils.makeExpressionTree(args, code);

	            if (args.length > 1) {
	                code.index = args[1].range[0];
	                throw code.makeError(
	                    args[1].range[0], args[1].range[1],
	                    'Unexpected Token: ' +
	                    JSON.stringify(args[1].source(code)) + '.'
	                );
	            }

	            transform.arguments.push(args[0]);

	            if (transform.nextArg) {
	                delete transform.nextArg;
	                delete transform.closed;
	            }

	            if (transform.closed) {
	                break;
	            }
	        }
	    } else {
	        return null;
	    }

	    return transform;
	}

	module.exports = parseExpressionTransform;


/***/ }),
/* 103 */
/***/ (function(module, exports, __webpack_require__) {

	// parseExpressionTransformEnd
	var Token = __webpack_require__(55);

	function parseExpressionTransformEnd(mode, code, tokens, flags, scope,
	    parseMode) {
	    if ( /* ) */
	        code.codePointAt(code.index) === 0x0029 &&
	        Token.tokens.transform.isCreation(scope.token)
	    ) {
	        code.index++;
	        scope.close();
	        parseMode.close();
	        return true;
	    }

	    if ( /* , */
	        code.codePointAt(code.index) === 0x002c &&
	        Token.tokens.transform.isCreation(scope.token)
	    ) {
	        code.index++;
	        scope.token.nextArg = true;
	        parseMode.close();
	        return true;
	    }

	    return null;
	}

	module.exports = parseExpressionTransformEnd;


/***/ }),
/* 104 */
/***/ (function(module, exports) {

	module.exports = function registerBarsWrapper(bars) {
	    return function registerBars(config) {
	        var _ = this,
	            key;

	        if (typeof config.transforms === 'object') {
	            for (key in config.transforms) {
	                if (config.transforms.hasOwnProperty(key)) {
	                    bars.registerTransform(key, config.transforms[key]);
	                }
	            }
	        }

	        if (typeof config.blocks === 'object') {
	            for (key in config.blocks) {
	                if (config.blocks.hasOwnProperty(key)) {
	                    bars.registerBlock(key, config.blocks[key]);
	                }
	            }
	        }

	        if (typeof config.partials === 'object') {
	            for (key in config.partials) {
	                if (config.partials.hasOwnProperty(key)) {
	                    bars.registerPartial(key, config.partials[key]);
	                }
	            }
	        }

	        _.definePrototype({
	            writable: true
	        }, {
	            template: config.template,
	            bars: bars
	        });
	    };
	};


/***/ }),
/* 105 */
/***/ (function(module, exports) {

	module.exports = function attach(config) {
	    var _ = this,
	        klass = config.class,
	        proto = config.proto,
	        key;

	    delete config.proto;
	    delete config.class;

	    _.registerConfig(config);

	    for (key in klass) {
	        _[key] = klass[key];
	    }

	    _.definePrototype({
	        writable: true,
	        configurable: true
	    }, proto);

	    config.class = klass;
	    config.proto = proto;
	};


/***/ }),
/* 106 */
/***/ (function(module, exports, __webpack_require__) {

	var Generator = __webpack_require__(107);
	var queryString = __webpack_require__(108);

	function fixPath(path) {
	    path = '/' + path;
	    path = path.replace(/[\/]+/g, '/');
	    path = path.replace(/[\/]$/g, '');

	    return path;
	}

	function isParamPath(path) {
	    return /[{][^{}\/]+[}]/.test(path);
	}

	var PARAM = /^[{]([^{}\/?*]+)(?:([?])|([*]([0-9]*)))?[}]$/;

	function parsePathParams(path) {
	    for (var i = 0; i < path.length; i++) {
	        var match = path[i].match(PARAM);

	        if (match) {
	            path[i] = {
	                name: match[1],
	                optional: !!match[2],
	                any: !!match[3],
	                anyAmount: match[4] ? Number(match[4]) : null
	            };
	        }
	    }

	    return path;
	}

	var Route = Generator.generate(
	    function Route(options, router, is404) {
	        var _ = this;

	        _.router = router;

	        _.pathString = fixPath(is404 ? '' : options.path);
	        _.path = parsePathParams(_.pathString.split('/'));
	        _.hasParams = isParamPath(_.pathString);
	        _.title = options.title;
	        _.handler = options.handler;
	    }
	);

	Route.definePrototype({
	    handleRoute: function handleRoute(path, search, hash, fullPath, noGo) {
	        var _ = this;

	        var req = {
	            title: _.title,
	            fullPath: fullPath,
	            path: path,
	            params: _.parseParams(path),
	            search: queryString.parse(search),
	            searchString: search,
	            hash: queryString.parse(hash),
	            hashString: hash
	        };

	        if (_.router) {
	            _.router.req = req;
	        }

	        if (noGo) {
	            return false;
	        }

	        return _.handler(req);
	    },
	    shouldTrigger: function shouldTrigger(path) {
	        var _ = this,
	            i;

	        path = fixPath(path)
	            .split('/');

	        if (!_.hasParams) {
	            if (path.length !== _.path.length) {
	                return false;
	            }

	            for (i = 0; i < path.length; i++) {
	                if (path[i] !== _.path[i]) {
	                    return false;
	                }
	            }
	        } else {
	            for (i = 0; i < _.path.length; i++) {
	                if (i === _.path.length - 1) {
	                    if (
	                        ((_.path[i].any || !_.path[i].optional) && !path[i]) ||
	                        (_.path[i].anyAmount &&
	                            i !== path.length - _.path[i].anyAmount - 1
	                        ) || (!_.path[i].any && path[i + 1])
	                    ) {
	                        return false;
	                    }
	                } else if (!_.path[i].name) {
	                    if (path[i] !== _.path[i]) {
	                        return false;
	                    }
	                }
	            }
	        }

	        return true;
	    },
	    parseParams: function parseParams(path) {
	        var _ = this;

	        path = fixPath(path)
	            .split('/');

	        var params = {};

	        for (var i = 0; i < _.path.length; i++) {
	            if (_.path[i].any) {
	                params[_.path[i].name] = path.slice(i, _.path[i].anyAmount)
	                    .join('/');
	                break;
	            } else if (_.path[i].name) {
	                params[_.path[i].name] = path[i];

	                if (_.path[i].optional) {
	                    break;
	                }
	            }
	        }

	        return params;
	    }
	});

	module.exports = Route;

	var BrowserRouter = Generator.generate(
	    function BrowserRouter(options) {
	        var _ = this;

	        _.routes = [];

	        _.root = options && options.root ? fixPath(options.root) : null;

	        _.mode = window.history ? ((options && options.mode) || 'path') : 'hash';

	        _._routeChangeHandler = function (e) {
	            _.go(null, true);
	        };

	        if (_.mode === 'path') {
	            window.addEventListener('popstate', _._routeChangeHandler, false);
	        } else {
	            _.bindHash();
	        }

	        window.addEventListener('beforeunload', _._beforeRouteChange.bind(_), false);
	    }
	);

	BrowserRouter.definePrototype({
	    bindHash: function bindHash() {
	        var _ = this;

	        window.addEventListener('hashchange', _._routeChangeHandler, false);
	    },
	    unbindHash: function unbindHash() {
	        var _ = this;

	        window.removeEventListener('hashchange', _._routeChangeHandler, false);
	    }
	});

	function noop() {}

	BrowserRouter.definePrototype({
	    writable: true
	}, {
	    beforeRouteChange: noop
	});

	BrowserRouter.definePrototype({
	    _beforeRouteChange: function _beforeRouteChange(evt) {
	        var _ = this;
	        var event = evt || {};

	        var result = _.beforeRouteChange(event);

	        if (result) {
	            event.returnValue = result;
	        }

	        if (!evt && event.returnValue) {
	            var con = confirm(event.returnValue);

	            return con ? void(0) : event.returnValue;
	        }

	        return result ? result : void(0);
	    },
	    start: function start(noGo) {
	        var _ = this;

	        _.go(null, true, noGo);
	    },

	    reload: function reload() {
	        var _ = this;

	        _.go(null, true);
	    },

	    addRoute: function addRoute(route) {
	        var _ = this;
	        _.routes.push(new Route(route, _));

	        _.routes.sort(function (a, b) {
	            if (!a.hasParams && b.hasParams) return -1;
	            if (a.hasParams && !b.hasParams) return 1;
	            if (a.pathString < b.pathString) return -1;
	            if (a.pathString > b.pathString) return 1;
	            return 0;
	        });
	    },
	    set404: function set404(route) {
	        var _ = this;

	        _.page404 = new Route(route, _, true);
	    },
	    go404: function go404() {
	        var _ = this;

	        if (_.page404) {
	            _._go(
	                _.page404,
	                window.location.pathname,
	                window.location.search,
	                window.location.hash,
	                true
	            );
	        } else {
	            console.warn('Page Not Found: ' + path + ' - no 404 route set.');
	        }
	    },

	    _go: function _go(route, path, search, hash, fromPopstate, noGo) {
	        var _ = this;

	        var isRedirect = false;
	        if (_._routeInProgress) {
	            _._routeRedirect = route;
	            isRedirect = true;
	        }

	        _._routeInProgress = route;

	        if (typeof route.title !== 'undefined') {
	            document.title = route.title;
	        }

	        path = _.resolve(path);
	        var fullPath = path;

	        if (search) {
	            fullPath += search;
	        }

	        if (hash) {
	            fullPath += hash;
	        }

	        var proceed = _._beforeRouteChange() ? false : true;

	        if (proceed) {
	            proceed = route.handleRoute(path, search, hash, fullPath, noGo);
	        }

	        if (proceed === false || (_._routeRedirect && _._routeRedirect !== route)) {
	            return;
	        }

	        if (_.mode === 'path') {
	            if (!fromPopstate) {
	                history.pushState({
	                    path: fullPath
	                }, route.title, fullPath);
	            }
	        } else {
	            if (!fromPopstate) {
	                _.unbindHash();
	                window.location.hash = fullPath;
	                setTimeout(function () {

	                    _.bindHash();
	                }, 0);
	            }
	        }

	        _._path = path;
	        _._search = search;
	        _._hash = hash;

	        if (!isRedirect) {
	            delete _._routeInProgress;
	            delete _._routeRedirect;
	        }
	    },
	    go: function go(path, fromPopstate, noGo) {
	        var _ = this;

	        var hash;
	        var search;

	        if (path === null) {
	            if (_.mode === 'path') {
	                path = window.location.pathname;
	                search = window.location.search;
	                hash = window.location.hash;
	            } else {
	                path = _.unresolve(window.location.hash.slice(1));
	            }
	        }

	        if (!search && !hash) {
	            var hashIndex = path.indexOf('#');
	            var searchIndex = path.indexOf('?');

	            if (hashIndex !== -1) {
	                hash = path.slice(hashIndex);
	                path = path.slice(0, hashIndex);
	            }

	            if (searchIndex !== -1) {
	                search = path.slice(searchIndex);
	                path = path.slice(0, searchIndex);
	            }
	        }

	        path = _.unresolve(_.resolve(path));

	        if ( // if route is same current don't proceed.
	            _._path === path &&
	            _._search === search &&
	            _._hash === hash
	        ) return;

	        var route = _.page404 || null;

	        for (var i = 0; i < _.routes.length; i++) {
	            if (_.routes[i].shouldTrigger(path)) {
	                route = _.routes[i];
	                break;
	            }
	        }

	        if (route) {
	            _._go(route, path, search, hash, fromPopstate, noGo);
	        } else {
	            console.warn('Page Not Found: ' + path + ' - no 404 route set.');
	        }
	    },
	    resolve: function resolve(path) {
	        var _ = this;

	        if (_.root && _.mode !== 'hash') {
	            path = _.root + '/' + path;
	        }

	        path = '/' + path;

	        return path.replace(/[\/]+/g, '/');
	    },
	    unresolve: function unresolve(path) {
	        var _ = this;

	        if (_.root && _.mode !== 'hash' && path.indexOf(_.root) === 0) {
	            path = path.slice(_.root.length);
	        }

	        return path.replace(/[\/]+/g, '/');
	    }
	});

	module.exports = BrowserRouter;


/***/ }),
/* 107 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/**
	 * @name generate.js
	 * @author Michaelangelo Jong
	 */

	(function GeneratorScope() {
	    /**
	     * Assert Error function.
	     * @param  {Boolean} condition Whether or not to throw error.
	     * @param  {String} message    Error message.
	     */
	    function assertError(condition, message) {
	        if (!condition) {
	            throw new Error(message);
	        }
	    }

	    /**
	     * Assert TypeError function.
	     * @param  {Boolean} condition Whether or not to throw error.
	     * @param  {String} message    Error message.
	     */
	    function assertTypeError(test, type) {
	        if (typeof test !== type) {
	            throw new TypeError('Expected \'' + type +
	                '\' but instead found \'' +
	                typeof test + '\'');
	        }
	    }

	    /**
	     * Returns the name of function 'func'.
	     * @param  {Function} func Any function.
	     * @return {String}        Name of 'func'.
	     */
	    function getFunctionName(func) {
	        if (func.name !== void(0)) {
	            return func.name;
	        }
	        // Else use IE Shim
	        var funcNameMatch = func.toString()
	            .match(/function\s*([^\s]*)\s*\(/);
	        func.name = (funcNameMatch && funcNameMatch[1]) || '';
	        return func.name;
	    }

	    /**
	     * Returns true if 'obj' is an object containing only get and set functions, false otherwise.
	     * @param  {Any} obj Value to be tested.
	     * @return {Boolean} true or false.
	     */
	    function isGetSet(obj) {
	        var keys, length;
	        if (obj && typeof obj === 'object') {
	            keys = Object.getOwnPropertyNames(obj)
	                .sort();
	            length = keys.length;

	            if ((length === 1 && (keys[0] === 'get' && typeof obj.get ===
	                    'function' ||
	                    keys[0] === 'set' && typeof obj.set === 'function'
	                )) ||
	                (length === 2 && (keys[0] === 'get' && typeof obj.get ===
	                    'function' &&
	                    keys[1] === 'set' && typeof obj.set === 'function'
	                ))) {
	                return true;
	            }
	        }
	        return false;
	    }

	    /**
	     * Defines properties on 'obj'.
	     * @param  {Object} obj        An object that 'properties' will be attached to.
	     * @param  {Object} descriptor Optional object descriptor that will be applied to all attaching properties on 'properties'.
	     * @param  {Object} properties An object who's properties will be attached to 'obj'.
	     * @return {Generator}         'obj'.
	     */
	    function defineObjectProperties(obj, descriptor, properties) {
	        var setProperties = {},
	            i,
	            keys,
	            length,

	            p = properties || descriptor,
	            d = properties && descriptor;

	        properties = (p && typeof p === 'object') ? p : {};
	        descriptor = (d && typeof d === 'object') ? d : {};

	        keys = Object.getOwnPropertyNames(properties);
	        length = keys.length;

	        for (i = 0; i < length; i++) {
	            if (isGetSet(properties[keys[i]])) {
	                setProperties[keys[i]] = {
	                    configurable: !!descriptor.configurable,
	                    enumerable: !!descriptor.enumerable,
	                    get: properties[keys[i]].get,
	                    set: properties[keys[i]].set
	                };
	            } else {
	                setProperties[keys[i]] = {
	                    configurable: !!descriptor.configurable,
	                    enumerable: !!descriptor.enumerable,
	                    writable: !!descriptor.writable,
	                    value: properties[keys[i]]
	                };
	            }
	        }
	        Object.defineProperties(obj, setProperties);
	        return obj;
	    }



	    var Creation = {
	        /**
	         * Defines properties on this object.
	         * @param  {Object} descriptor Optional object descriptor that will be applied to all attaching properties.
	         * @param  {Object} properties An object who's properties will be attached to this object.
	         * @return {Object}            This object.
	         */
	        defineProperties: function defineProperties(descriptor,
	            properties) {
	            defineObjectProperties(this, descriptor,
	                properties);
	            return this;
	        },

	        /**
	         * returns the prototype of `this` Creation.
	         * @return {Object} Prototype of `this` Creation.
	         */
	        getProto: function getProto() {
	            return Object.getPrototypeOf(this);
	        },

	        /**
	         * returns the prototype of `this` super Creation.
	         * @return {Object} Prototype of `this` super Creation.
	         */
	        getSuper: function getSuper() {
	            return Object.getPrototypeOf(this.constructor.prototype);
	        }
	    };

	    var Generation = {
	        /**
	         * Returns true if 'generator' was generated by this Generator.
	         * @param  {Generator} generator A Generator.
	         * @return {Boolean}             true or false.
	         */
	        isGeneration: function isGeneration(generator) {
	            assertTypeError(generator, 'function');

	            var _ = this;

	            return _.prototype.isPrototypeOf(generator.prototype);
	        },

	        /**
	         * Returns true if 'object' was created by this Generator.
	         * @param  {Object} object An Object.
	         * @return {Boolean}       true or false.
	         */
	        isCreation: function isCreation(object) {
	            var _ = this;
	            return object instanceof _;
	        },
	        /**
	         * Generates a new generator that inherits from `this` generator.
	         * @param {Generator} ParentGenerator Generator to inherit from.
	         * @param {Function} create           Create method that gets called when creating a new instance of new generator.
	         * @return {Generator}                New Generator that inherits from 'ParentGenerator'.
	         */
	        generate: function generate(construct) {
	            assertTypeError(construct, 'function');

	            var _ = this;

	            defineObjectProperties(
	                construct, {
	                    configurable: false,
	                    enumerable: false,
	                    writable: false
	                }, {
	                    prototype: Object.create(_.prototype)
	                }
	            );

	            defineObjectProperties(
	                construct, {
	                    configurable: false,
	                    enumerable: false,
	                    writable: false
	                },
	                Generation
	            );

	            defineObjectProperties(
	                construct.prototype, {
	                    configurable: false,
	                    enumerable: false,
	                    writable: false
	                }, {
	                    constructor: construct,
	                    generator: construct,
	                }
	            );

	            return construct;
	        },

	        /**
	         * Defines shared properties for all objects created by this generator.
	         * @param  {Object} descriptor Optional object descriptor that will be applied to all attaching properties.
	         * @param  {Object} properties An object who's properties will be attached to this generator's prototype.
	         * @return {Generator}         This generator.
	         */
	        definePrototype: function definePrototype(descriptor,
	            properties) {
	            defineObjectProperties(this.prototype,
	                descriptor,
	                properties);
	            return this;
	        }
	    };

	    function Generator() {}

	    defineObjectProperties(
	        Generator, {
	            configurable: false,
	            enumerable: false,
	            writable: false
	        }, {
	            prototype: Generator.prototype
	        }
	    );

	    defineObjectProperties(
	        Generator.prototype, {
	            configurable: false,
	            enumerable: false,
	            writable: false
	        },
	        Creation
	    );

	    defineObjectProperties(
	        Generator, {
	            configurable: false,
	            enumerable: false,
	            writable: false
	        },
	        Generation
	    );

	    defineObjectProperties(
	        Generator, {
	            configurable: false,
	            enumerable: false,
	            writable: false
	        }, {
	            /**
	             * Returns true if 'generator' was generated by this Generator.
	             * @param  {Generator} generator A Generator.
	             * @return {Boolean}             true or false.
	             */
	            isGenerator: function isGenerator(generator) {
	                return this.isGeneration(generator);
	            },

	            /**
	             * Generates a new generator that inherits from `this` generator.
	             * @param {Generator} extendFrom      Constructor to inherit from.
	             * @param {Function} create           Create method that gets called when creating a new instance of new generator.
	             * @return {Generator}                New Generator that inherits from 'ParentGenerator'.
	             */
	            toGenerator: function toGenerator(extendFrom, create) {
	                console.warn(
	                    'Generator.toGenerator is depreciated please use Generator.generateFrom'
	                );
	                return this.generateFrom(extendFrom, create);
	            },

	            /**
	             * Generates a new generator that inherits from `this` generator.
	             * @param {Constructor} extendFrom    Constructor to inherit from.
	             * @param {Function} create           Create method that gets called when creating a new instance of new generator.
	             * @return {Generator}                New Generator that inherits from 'ParentGenerator'.
	             */
	            generateFrom: function generateFrom(extendFrom, create) {
	                assertTypeError(extendFrom, 'function');
	                assertTypeError(create, 'function');

	                defineObjectProperties(
	                    create, {
	                        configurable: false,
	                        enumerable: false,
	                        writable: false
	                    }, {
	                        prototype: Object.create(extendFrom.prototype),
	                    }
	                );

	                defineObjectProperties(
	                    create, {
	                        configurable: false,
	                        enumerable: false,
	                        writable: false
	                    },
	                    Generation
	                );

	                defineObjectProperties(
	                    create.prototype, {
	                        configurable: false,
	                        enumerable: false,
	                        writable: false
	                    }, {
	                        constructor: create,
	                        generator: create,
	                    }
	                );

	                defineObjectProperties(
	                    create.prototype, {
	                        configurable: false,
	                        enumerable: false,
	                        writable: false
	                    },
	                    Creation
	                );

	                return create;
	            }
	        }
	    );

	    Object.freeze(Generator);
	    Object.freeze(Generator.prototype);

	    // Exports
	    if (true) {
	        // AMD
	        !(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
	            return Generator;
	        }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	    } else if (typeof module === 'object' && typeof exports === 'object') {
	        // Node/CommonJS
	        module.exports = Generator;
	    } else {
	        // Browser global
	        window.Generator = Generator;
	    }

	}());


/***/ }),
/* 108 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var strictUriEncode = __webpack_require__(109);
	var objectAssign = __webpack_require__(110);

	function encoderForArrayFormat(opts) {
		switch (opts.arrayFormat) {
			case 'index':
				return function (key, value, index) {
					return value === null ? [
						encode(key, opts),
						'[',
						index,
						']'
					].join('') : [
						encode(key, opts),
						'[',
						encode(index, opts),
						']=',
						encode(value, opts)
					].join('');
				};

			case 'bracket':
				return function (key, value) {
					return value === null ? encode(key, opts) : [
						encode(key, opts),
						'[]=',
						encode(value, opts)
					].join('');
				};

			default:
				return function (key, value) {
					return value === null ? encode(key, opts) : [
						encode(key, opts),
						'=',
						encode(value, opts)
					].join('');
				};
		}
	}

	function parserForArrayFormat(opts) {
		var result;

		switch (opts.arrayFormat) {
			case 'index':
				return function (key, value, accumulator) {
					result = /\[(\d*)\]$/.exec(key);

					key = key.replace(/\[\d*\]$/, '');

					if (!result) {
						accumulator[key] = value;
						return;
					}

					if (accumulator[key] === undefined) {
						accumulator[key] = {};
					}

					accumulator[key][result[1]] = value;
				};

			case 'bracket':
				return function (key, value, accumulator) {
					result = /(\[\])$/.exec(key);
					key = key.replace(/\[\]$/, '');

					if (!result) {
						accumulator[key] = value;
						return;
					} else if (accumulator[key] === undefined) {
						accumulator[key] = [value];
						return;
					}

					accumulator[key] = [].concat(accumulator[key], value);
				};

			default:
				return function (key, value, accumulator) {
					if (accumulator[key] === undefined) {
						accumulator[key] = value;
						return;
					}

					accumulator[key] = [].concat(accumulator[key], value);
				};
		}
	}

	function encode(value, opts) {
		if (opts.encode) {
			return opts.strict ? strictUriEncode(value) : encodeURIComponent(value);
		}

		return value;
	}

	function keysSorter(input) {
		if (Array.isArray(input)) {
			return input.sort();
		} else if (typeof input === 'object') {
			return keysSorter(Object.keys(input)).sort(function (a, b) {
				return Number(a) - Number(b);
			}).map(function (key) {
				return input[key];
			});
		}

		return input;
	}

	exports.extract = function (str) {
		return str.split('?')[1] || '';
	};

	exports.parse = function (str, opts) {
		opts = objectAssign({arrayFormat: 'none'}, opts);

		var formatter = parserForArrayFormat(opts);

		// Create an object with no prototype
		// https://github.com/sindresorhus/query-string/issues/47
		var ret = Object.create(null);

		if (typeof str !== 'string') {
			return ret;
		}

		str = str.trim().replace(/^(\?|#|&)/, '');

		if (!str) {
			return ret;
		}

		str.split('&').forEach(function (param) {
			var parts = param.replace(/\+/g, ' ').split('=');
			// Firefox (pre 40) decodes `%3D` to `=`
			// https://github.com/sindresorhus/query-string/pull/37
			var key = parts.shift();
			var val = parts.length > 0 ? parts.join('=') : undefined;

			// missing `=` should be `null`:
			// http://w3.org/TR/2012/WD-url-20120524/#collect-url-parameters
			val = val === undefined ? null : decodeURIComponent(val);

			formatter(decodeURIComponent(key), val, ret);
		});

		return Object.keys(ret).sort().reduce(function (result, key) {
			var val = ret[key];
			if (Boolean(val) && typeof val === 'object' && !Array.isArray(val)) {
				// Sort object keys, not values
				result[key] = keysSorter(val);
			} else {
				result[key] = val;
			}

			return result;
		}, Object.create(null));
	};

	exports.stringify = function (obj, opts) {
		var defaults = {
			encode: true,
			strict: true,
			arrayFormat: 'none'
		};

		opts = objectAssign(defaults, opts);

		var formatter = encoderForArrayFormat(opts);

		return obj ? Object.keys(obj).sort().map(function (key) {
			var val = obj[key];

			if (val === undefined) {
				return '';
			}

			if (val === null) {
				return encode(key, opts);
			}

			if (Array.isArray(val)) {
				var result = [];

				val.slice().forEach(function (val2) {
					if (val2 === undefined) {
						return;
					}

					result.push(formatter(key, val2, result.length));
				});

				return result.join('&');
			}

			return encode(key, opts) + '=' + encode(val, opts);
		}).filter(function (x) {
			return x.length > 0;
		}).join('&') : '';
	};


/***/ }),
/* 109 */
/***/ (function(module, exports) {

	'use strict';
	module.exports = function (str) {
		return encodeURIComponent(str).replace(/[!'()*]/g, function (c) {
			return '%' + c.charCodeAt(0).toString(16).toUpperCase();
		});
	};


/***/ }),
/* 110 */
/***/ (function(module, exports) {

	/*
	object-assign
	(c) Sindre Sorhus
	@license MIT
	*/

	'use strict';
	/* eslint-disable no-unused-vars */
	var getOwnPropertySymbols = Object.getOwnPropertySymbols;
	var hasOwnProperty = Object.prototype.hasOwnProperty;
	var propIsEnumerable = Object.prototype.propertyIsEnumerable;

	function toObject(val) {
		if (val === null || val === undefined) {
			throw new TypeError('Object.assign cannot be called with null or undefined');
		}

		return Object(val);
	}

	function shouldUseNative() {
		try {
			if (!Object.assign) {
				return false;
			}

			// Detect buggy property enumeration order in older V8 versions.

			// https://bugs.chromium.org/p/v8/issues/detail?id=4118
			var test1 = new String('abc');  // eslint-disable-line no-new-wrappers
			test1[5] = 'de';
			if (Object.getOwnPropertyNames(test1)[0] === '5') {
				return false;
			}

			// https://bugs.chromium.org/p/v8/issues/detail?id=3056
			var test2 = {};
			for (var i = 0; i < 10; i++) {
				test2['_' + String.fromCharCode(i)] = i;
			}
			var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
				return test2[n];
			});
			if (order2.join('') !== '0123456789') {
				return false;
			}

			// https://bugs.chromium.org/p/v8/issues/detail?id=3056
			var test3 = {};
			'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
				test3[letter] = letter;
			});
			if (Object.keys(Object.assign({}, test3)).join('') !==
					'abcdefghijklmnopqrst') {
				return false;
			}

			return true;
		} catch (err) {
			// We don't expect any of the above to throw, but better to be safe.
			return false;
		}
	}

	module.exports = shouldUseNative() ? Object.assign : function (target, source) {
		var from;
		var to = toObject(target);
		var symbols;

		for (var s = 1; s < arguments.length; s++) {
			from = Object(arguments[s]);

			for (var key in from) {
				if (hasOwnProperty.call(from, key)) {
					to[key] = from[key];
				}
			}

			if (getOwnPropertySymbols) {
				symbols = getOwnPropertySymbols(from);
				for (var i = 0; i < symbols.length; i++) {
					if (propIsEnumerable.call(from, symbols[i])) {
						to[symbols[i]] = from[symbols[i]];
					}
				}
			}
		}

		return to;
	};


/***/ }),
/* 111 */
/***/ (function(module, exports) {

	module.exports = "{{>header}}\n{{>sidebar}}\n{{>issue}}\n";

/***/ }),
/* 112 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = "<article>\n    <header style=\"background: {{issue.color}}\">\n        <div class=\"container\">\n            <h1>\n                {{#if @empty(issue.stances)}}Gov.Vote - {{/if}}\n                {{issue.title}}\n            </h1>\n\n            <p>{{issue.description}}</p>\n\n            <img src=\"" + __webpack_require__(113) + "\" class=\"bg\">\n        </div>\n    </header>\n\n    <content>\n        <div class=\"container\">\n            {{#if issue.content}}\n                {{issue.content}}\n            {{/if}}\n\n            {{#if @any(issue.stances)}}\n                {{#if stance}}\n                    {{>stance}}\n                {{else}}\n                    {{>stances}}\n                {{/if}}\n            {{/if}}\n\n            <a class=\"notice-2\">\n                Have something to say?<br>\n                Visit us on GitHub.\n            </a>\n        </div>\n    </content>\n</article>\n";

/***/ }),
/* 113 */
/***/ (function(module, exports) {

	module.exports = "data:image/jpeg;base64,/9j/4QAYRXhpZgAASUkqAAgAAAAAAAAAAAAAAP/sABFEdWNreQABAAQAAABGAAD/4QQIaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wLwA8P3hwYWNrZXQgYmVnaW49Iu+7vyIgaWQ9Ilc1TTBNcENlaGlIenJlU3pOVGN6a2M5ZCI/PiA8eDp4bXBtZXRhIHhtbG5zOng9ImFkb2JlOm5zOm1ldGEvIiB4OnhtcHRrPSJBZG9iZSBYTVAgQ29yZSA1LjYtYzExMSA3OS4xNTgzMjUsIDIwMTUvMDkvMTAtMDE6MTA6MjAgICAgICAgICI+IDxyZGY6UkRGIHhtbG5zOnJkZj0iaHR0cDovL3d3dy53My5vcmcvMTk5OS8wMi8yMi1yZGYtc3ludGF4LW5zIyI+IDxyZGY6RGVzY3JpcHRpb24gcmRmOmFib3V0PSIiIHhtbG5zOnhtcFJpZ2h0cz0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL3JpZ2h0cy8iIHhtbG5zOnhtcE1NPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvbW0vIiB4bWxuczpzdFJlZj0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL3NUeXBlL1Jlc291cmNlUmVmIyIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczpkYz0iaHR0cDovL3B1cmwub3JnL2RjL2VsZW1lbnRzLzEuMS8iIHhtcFJpZ2h0czpNYXJrZWQ9IkZhbHNlIiB4bXBNTTpPcmlnaW5hbERvY3VtZW50SUQ9Ijg5MjIyODk5RkZEODc3Rjg5MEJCMzA0OUQyNkZCRkRBIiB4bXBNTTpEb2N1bWVudElEPSJ4bXAuZGlkOjM0MDNCNEZFQTVFOTExRTY4NzgyQUE1QURERTgyREMzIiB4bXBNTTpJbnN0YW5jZUlEPSJ4bXAuaWlkOjM0MDNCNEZEQTVFOTExRTY4NzgyQUE1QURERTgyREMzIiB4bXA6Q3JlYXRvclRvb2w9IkFkb2JlIFBob3Rvc2hvcCBDUzMgTWFjaW50b3NoIj4gPHhtcE1NOkRlcml2ZWRGcm9tIHN0UmVmOmluc3RhbmNlSUQ9InhtcC5paWQ6NEI5NkVGRjk2NTQ1MTFF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QQSAAAAAACQACLLZLSSQACQQSSSbZZKSADZZLLYZASRACAQAAAAASQACBbbZIQDJSbZbCSFCSACCAQQCQACAAAbQCASACAAACACASCCTLLZZCSQSQQACCALbYSALJJLLIQSQRSCSSQAQSQSAAQDLLbIQABQDLJQQBCAAQQAAAQAJJJaDbACAAQQQAAACSCSQQSbLZLIASCCSCQSCCZICSZZbKYCSSCBCQSASSCCCSCACDZJJaQCZARbZAAVACSAAQQCBJJJJJJbYIaWAASAAAAQCCAQSDbJbLSAQAAQCACQQKBJZZSSASCAAACCSQSACQAQACCJJLZYAQCARbZaQSSAACACAABJJJJJLSCCKLBLQgAAASCACASSZLbaSQSQSQCSACSAJZLIQCASSCSAQASSCACCSQACCLJZISSASgCKDAAQAQAQAQCCJJJIIbJbYSQTZJZbbZZYCAACAAbbLJQQACSACSQSSDJbLaCQQCSSQQSSAAIQISASQSZZZQAAASDQwQ5ACQCCQAAQQJJJbYSSTbKDYTTDJLLJIYAAACCYLJLJCCCACSSSCCSTJbZCCCSQCCACAAADbRLSACARbbYSSASABLQASSCSAAAAAEbBAbZbKYDQSCZTCDCACALRaQCSACRLbbaTbQCSAQQQSTLJLAACCSCCSASSBLJRKSQSAJZYIAQSQCCSUSSQCQAQABJIQBaAAKSCQSCTICYbDJbZLLJQSAAALJLJJCQBJACCSCABbbZAACCACSACQBZKJRSAQQZbbbYCACSQUKQSSQAAAAASCZRZQSCQRAkSSSQAQCTAACCICIQQQRDJZJbZAARgQQQCQTZbKQSAASCACQSDLJJACSCRLJLIQCAQQRYKSCCAAAQACSZDAQQBISSQmGgESQQCDZKRCAAACSQRBbJLZZDSQCQQSAATbJQSAASQQSCCSDZZbbJbJLbJbAASSSCCCSSCQAAQSCASRCSASCQgSAAG20ACSIYCCRQAAAACCALRZLJLZaQQKACQSBJJAACAAQSASQCDJLZZZbbJJLICQQQAASSQQQAAQQCDAYAQTSIaDAASSmRGySASCAAAQACQAQABbCJLZbZbABCQQSSDZbACAASQASCQCJZLbbLLbbbaKASSCACSJQSCCAAAAYJIQAQIw4AQQASSSG2SQSQAACAAAQCARbCSbbJZJJAAACQQABJaCQCCAASQBATLLbTRLZLZQQAQCSCCCSTAACAAQQETbCQSQDCqAQQCTSSQlQQQAAACQAQCAATJLbJJLbLLCCbAACSDLYCAACAAQDbCDKSATKDZbbQACAACACASCCAAQCAQLBICCACCIISCSDbAAQFCSACQCQCQAAASBZZbZJJLLbSCBICCQBZSCCCSACCCbKBTCCSKRZJaSCAQCCCSASQCCASCAALCAZIAYAIAACCQBbZGRQQQSQAAAQCSQBZJLZbbLbJbQSCQQAQDZCSCQQBITbLKRQSSSQAJLLQASCASSQQAAQQASCQAAAAAACAQCKCQQYQSCBZASSQQQASSCSCZJZJJJbJJLZYAASCAQBJCSAQSRbJLLbLSAQCSARJQASCSAAAQAQQAAAAQQACCAAAAACSYSCSQJQSSSQAASCQASAAAAbLLJJLbJJZJLSSCSASBACASALbJZZKJbSSQAAAbQASSSSAQAQAQAACQACAAQAAAAAJJbCCQQQDKBKCSAAQACASSQQbZJLbJJLJJZJJAQBaCQCSSQCQJJZZbZaJQAQSAQCQSCQASAQACQAAACSQAAAQACAbCSASQDKIKQQRLICSyCQAQACSASJJJLLZJJJLZZACSBaCQCCSSAbZbLLICQQCASSQQQCASAAAQAACAAAAAAAIQUQDZKAQICZQbIQCAAJDbYRSCCAAQACCZbZJJJZZJZZZbYQBYASQSSASZZZJbLCaCAAQSCCSSQAAAACAAAAAAACJLbZCZJaCASTIZCASCSTJCYATCSNtICASCbJLJZbJbJJZJSAASQIQSSQAABLJJLbISaCAACCAQAQQACAAAAAAQAABBJZCDYLISSBRbAaCBbISGySCCQQATTCCAQAZZLbJLZJJJZJSQAAaYASSSAQRbbbaKaACSAAAQAQAAQAAAAAQACCABJLZAbQbCSCKRYJSAAQCKAAQASCQQAAGcISAALZJJJJZZJJbJYQAQLLASCCAQTLbKKZKACCQAAAAAQSQCAACAAAAABLLZDYCbSCSKSYBQASAQBDQASQAARbQSQJUIUQSZJLJLbLJJZLIAAAJaQQSQSCBLZYbRASCAACASASAQCAAASAASQAJJYTJTaAAQVDaaSSSQSCIbSTQIJCebIADDWdCAZZJJJJJZJJZLKACTJaQQQAAALZbIISGCSAAASQCQCQCAQCQACAABJYBKBQQCCQSBSCCaQSSQYZARADJQNSQCQbRSSQLZJZbLZJZLJbZCSCbKQCSSCAbbJZYBIAACCCCCQSQCSAQAAAQAAbKTYDYSQCgJBSAKSaAASTISARCDJaBKACATSQAQARLZJJLZJLJLACQQLJYSCSSTZJJbZDCAQASASCAASCCCAAAQAADJTYRAQAAEbSICagAAQQCCISQTCATZhZKSiRRCSQATLJJLZZJLJJbIQSJJICASSCZLJZbRCiQCCCSQJIAAAAAQAAAALaCSAQASAYTDRDLZYSAATQbQQSSCALDDAKQSQQSATZJJJbJLJLJLICACBLaSAAABbZLLZLZSAAQQQTBLCCAAAAAAACKQSIRDSBCCAIASAJLBbIJKZBZaSQRAbZAQSQAQbZJLJJJJJZJLJLIQAQDKSQQSSTLLZLbTKCASAQCBRIACCAAQCCLLbTADJASQASTATQLTSSACCAQSCCTASALb2EAQAQSZbJK5bJJZJLJLLCCCCRSQSCQDJbbLJLLCAAAAACJIQAAQWU7ZJbJJJbCSCIiQAQQCCCSCSSQKACCQKaKZQKwTQSKSSbQZaQLJJJZJLJIACACZBSSSQCLbLLbLaIAAQQSKJZAAClZJLJLZZZbKQDZLSSSSCQCSASAAAQACRAYRBBAICTSBASQSTCWtJZJZZJZJLKAACRLaCCSQZbJZbZYaaSSSBZJIAFJJbZbJZJLJeSCAQCQQAJCAQSSQSCAASSCAaQDaCTQLADICCQCRKrbJJbJLJJLICAQLZKASQaAbLJZbIaQTBLJJJYLJLJZJLZLZKAACAQTICQRSSAAQASAQASQASSQDQSbRhAQAQQCCSQRxJJLLZJJJZISQCTJKAQCICIJLbLLZZJZLZJbLLbLbbJLJUfMVSARaQCACRYASAQSASSSSCAAAAaaCBcAaEKQSASSAmZZJJJZJZJLJCAARZISSQDISZZbJLJJZZbJJJLZJZISC0z3j5AAQBCQQACQYCCQSSAACAAAAACQZITTSKCCaJDYQCAQ5ZJLJLJJJLIAQAQJKCSQRKAZJJbJLbLbbZLZbJJaY2AVU66KGCRLaaCLQCAQSASCACASSSSSQBRATBSASSKAARCyQTJJJJZJJJZLZIQAABKQQSQbSBIBZZbJJJJJBYDZABZn0ze3AAAQZaCSQCBCCCACSQSCASACAACDQTKYDACBSCSCRQASZJJJJJJJLJJZAAARKQSQTJaCITJJLbZLJbJSAdKBC9RQQACSCCaAASQCSYAQQQSCAQAAAQbDIKQDAYCQCYAQACAaSSZJJJJJJJJJJJKAARKCQSCDYACRJLZbLJJJCYaRRQCTKATZSSQSSCASSQABQCAQCSQACAAAQAJWiJJYSADQAQJICCCQZJLZJJLJJJJJICQAASSSSBIACRJJbJLJbLSBQLYYSCASQTISSaCQCJAQQSaASQCAAAABJLZIRSyCCCQQbCAKKZCDQALJJZJJLJJJJZIAAASQQCSDKCSDZLbJJZJbDBJKIDCSSSQICYZQQQiYKaCCSCSQAIJJLIBLJLKCSCAQQQaQQTAbYCSSBJJLJJLJJZJJJAAAASSCSJYCCQbLJLJJJJQRLQCCZYTQTIAZSSCSSIALAATAALbLLZJJbJJJZCQAQSCSKQILZIDAAQRJJJJJJZJZJJJIAACSSSAJICSQQJZJZLJJAZLLSASQZCJaSQIQCBDCaKIAACRJLJJJJZJJJJYCSCSSSaSQIRRJxACCRZJLJJJbJLJJJIAACSQSAZIQAQDJZLZLZJQQCJbLZDBRCQCSQQbDCBRYgQAISCCBJJJJLZJCSSSSQAABQAKRZORKIDJJJJJJJLJJJJJIQACSQQALLYQAAZJJLJbZAQSRJLKYRTNACTABQaaIKaDSACASAQRZLJCCAAQCSQCAABCCZSZ8UbBSRLJJZJJLJLJJJISACAAAQQACQQCSRZZLLKCQCQLJZLZJ5CCAADKTYqbEaCRIaDRJaSAACAAQRCSQAQQBAAZaa+JbBBDJLJJbJZLZJJKAACQQCJbAACABZADJJbJYaSQALLJJbZSACCQKAKRAYWCSBBbLSACICQACSCRCQTAQQTAKaBbnNCQC5ZZbLLZLbZJbCSAAAATbZJAAAJJJJbJJLJRRTbIJZbaLaAAISSLbBLZpCICTLYRbJQZZLaTLSASQYCTaCQBLBHSZQBLbbbZbZJCAAQAQABICQQLACQAbLJJJLJLZZCQAAZLKbaLCQYCCCSbbYdAICRZZLZLJKKCSAADaRIaItYASRQJnJYSCSbAAQAQQACADASASSSSQJSQCQTJJZJJbLbYCCCaKSQQQSDAKASQSKYSkNaTCZRAAACAQAAAQZASSTACCQAJDDTZKSCLYAQCSCSBAAADSCQQCQRYAQSJbJLZbLZbJQKCACRLZZZbJLDaCLZQRQKHALCQCASQQACAQQQAbCQQQAQACCQbCACSCCAQSQACAQSQCASSSAASASCAaLLbLbZbZZLJCCRQICSSAQSCDKBZAaISSCSBQSCQQAAASSQJaZaTYQZJTAQQJSRAJJLYAQACCSSQCQAQQAQASCCTAJbbJbZLJJJJbbJbYAWKQTZSAATIDSRSRaYYSDRLJLLZICACACCSSQCSACCCSQDbYTSCSDZaSAQAQCAQASQSCASSSSDZbbLbJJZJJLLJLJJJKQCQCSQSAASaDYITTaAASACSAAQCSQQAACQSAAASCQCQAAQAZAASCSAAAQQCACAASSQSQCAZIbZbJZZZLLLZZLJCALJZCSQCASQSASZSKSDCCCSSSSACSAAAAACSSQQSCSAQACCTQCAKQbRKAQQSAQCQQCSQACCCQASCLLbLJLbJbJLIKbCASRSSCCSSSQCCDCISKCSSSAAAACSQCCQSSSSSSSASCSASCQQLKASCCASQSCQCCCSSQASQACAQSDAZLbZLbLbLbBQCQCAaCCACQQCCAQCZKbSAQQQCQCSCASCASSCCQCSSSQASSRLLaSQAQSSZAACSQCSSQACCSCQQQQQLTbQbZLAABbJKATACACJbZSSCQQQCCSAQQCCQSKSSCQQCSbRQSQCKACTJbJJQCCSAAACAYCSQAAAAQCASAACQSCQACbCCQDbLQAZKZCCSQCAIAQQQQQQCDLLKQSSQQaCCQbICCDbJLZSQQQAACCQQCCQSSAACAQACCCQSQQSSASQCSQAQSACCSSQCCQBbbbbaALDLbJYQSCSCSYQQQZbbLYbTTLbLbaQZbZLbQAAQLJSSQQCCSCQQAQSCSASQQASAACQQQQQSQAAQAQCASCQSJJZLZZBbZLZZJLIAIQCbbLLabZaaQAAJLbaCAbLJbbQCCAAASSCQASQSSAAQQCQSSQQSCQQCQQSASQSSASQSASSSCTBJbZZAAQRaZZCSSTSAQbaLbSAKaCASQKADASQQKAbQSAACQASCSQACAAQQQSQQSCSSAQSSCAQQQCZYCQQQSSSCQCASSSAQSbSASSQTSSSQSACAQRKSASCCCSAASSCAACSCASSAQCCQCAQCSCSQQSAQSCSAAAQSACASCACABaQQAQQCQACSCACAACRBAASQCCQCSCA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"

/***/ }),
/* 114 */
/***/ (function(module, exports) {

	module.exports = "<site-header>\n    <a href=\"/\" class=\"message\">\n        <span class=\"ellipsis\">\n            {{site.description}}\n        </span>\n    </a>\n\n    <nav>\n        <ul class=\"meta\">\n            <li>\n                <a href=\"/\">\n                    About\n                </a>\n            </li>\n        </ul>\n\n        <ul class=\"core\">\n            <li class=\"logo\">\n                <a href=\"#\" class=\"toggle-sidebar\">\n                    <span class=\"mobile-only\">=</span>\n                    <span class=\"desktop-only\">Gov.Vote</span>\n                </a>\n            </li>\n\n            <li class=\"site-name\">\n                <a href=\"/\" class=\"highlight\">\n                    <span class=\"ellipsis\">\n                        {{site.title}}\n                    </span>\n                </a>\n            </li>\n        </ul>\n    </nav>\n</site-header>\n\n<site-header-placeholder></site-header-placeholder>\n";

/***/ }),
/* 115 */
/***/ (function(module, exports) {

	module.exports = "<sidebar>\n    <ul>\n        <li class=\"divider\">\n            Issues\n        </li>\n\n        {{#with prefix=prefix issue=issue}}\n            {{#each site.issues}}\n                <li>\n                    <a href=\"#{{prefix}}/{{@key}}\" class=\"{{issue.permalink === @key && 'active'}}\">\n                        <span>{{title}}</span>\n                        <small>{{description}}</small>\n                    </a>\n                </li>\n            {{/each}}\n        {{/with}}\n    </ul>\n</sidebar>\n";

/***/ }),
/* 116 */
/***/ (function(module, exports) {

	module.exports = "<stances>\n    <!-- <p class=\"notice\">\n        Read more about the issue &amp; check the stance you agree with:\n    </p> -->\n\n    {{#with issue=issue prefix=prefix}}\n        {{#each issue.stances}}\n            <stance>\n                <h1>\n                    <span class=\"dot\"></span>\n                    <a href=\"#{{prefix}}/{{issue.permalink}}/{{@key}}\">\n                        {{title}}\n                    </a>\n                </h1>\n\n                <stance-content>\n                    <p>\n                        {{description}}\n                        <a href=\"#{{prefix}}/{{issue.permalink}}/{{@key}}\" class=\"read-more\">Read More</a>\n                    </p>\n                </stance-content>\n            </stance>\n        {{/each}}\n    {{/with}}\n\n    <!--<stance>\n        <h1>\n            <span class=\"dot\"></span>Add Your Stance\n        </h1>\n        <stance-content>\n            <p>\n                <hr>\n                <hr>\n                <hr>\n            </p>\n        </stance-content>\n    </stance>-->\n</stances>\n";

/***/ }),
/* 117 */
/***/ (function(module, exports) {

	module.exports = {
		"ca": {
			"permalink": "ca",
			"en": {
				"permalink": "en",
				"title": "Canada",
				"description": "Gov.Vote is a safe & secure platform to explore important issues. We never save any data about you.",
				"color": "#2E3131",
				"content": "Blah",
				"issues": {
					"carbon": {
						"permalink": "carbon",
						"title": "Carbon Taxes",
						"description": "Carbon taxes are just a money grab. Carbon taxes are just a money grab. Carbon taxes are just a money grab.",
						"color": "#3F371E",
						"stances": {
							"yes": {
								"permalink": "yes",
								"title": "Don't do it.",
								"description": "Or do it."
							},
							"no": {
								"permalink": "no",
								"title": "Do it.",
								"description": "Just do it."
							}
						}
					},
					"firearms": {
						"permalink": "firearms",
						"title": "Firearms",
						"description": "Carbon taxes are just a money grab. Carbon taxes are just a money grab. Carbon taxes are just a money grab.",
						"color": "#770701",
						"content": "Coming Soon!"
					},
					"globalism": {
						"permalink": "globalism",
						"title": "Globalism",
						"description": "Carbon taxes are just a money grab. Carbon taxes are just a money grab. Carbon taxes are just a money grab.",
						"color": "#022556",
						"content": "Coming Soon!"
					},
					"marijuana": {
						"permalink": "marijuana",
						"title": "Marijuana",
						"description": "Carbon taxes are just a money grab. Carbon taxes are just a money grab. Carbon taxes are just a money grab.",
						"color": "#0D6801",
						"content": "Coming Soon!"
					},
					"multiculturalism": {
						"permalink": "multiculturalism",
						"title": "Multiculturalism",
						"description": "Carbon taxes are just a money grab. Carbon taxes are just a money grab. Carbon taxes are just a money grab.",
						"color": "#4E0028",
						"content": "Coming Soon!"
					},
					"refugees": {
						"permalink": "refugees",
						"title": "Refugees",
						"description": "Carbon taxes are just a money grab. Carbon taxes are just a money grab. Carbon taxes are just a money grab.",
						"color": "#604001",
						"content": "Coming Soon!"
					},
					"renewables": {
						"permalink": "renewables",
						"title": "Renewable Energy",
						"description": "Carbon taxes are just a money grab. Carbon taxes are just a money grab. Carbon taxes are just a money grab.",
						"color": "#0D6A47",
						"content": "Coming Soon!"
					},
					"abortion": {
						"permalink": "abortion",
						"title": "Abortion",
						"description": "Carbon taxes are just a money grab. Carbon taxes are just a money grab. Carbon taxes are just a money grab.",
						"color": "#3D0D4B",
						"content": "Coming Soon!"
					},
					"gay": {
						"permalink": "gay",
						"title": "Gay Marriage",
						"description": "Carbon taxes are just a money grab. Carbon taxes are just a money grab. Carbon taxes are just a money grab.",
						"color": "#184743",
						"content": "Coming Soon!"
					},
					"space": {
						"permalink": "space",
						"title": "Space Exploration",
						"description": "Carbon taxes are just a money grab. Carbon taxes are just a money grab. Carbon taxes are just a money grab.",
						"color": "#27292A",
						"content": "Coming Soon!"
					},
					"healthcare": {
						"permalink": "healthcare",
						"title": "Healthcare",
						"description": "Carbon taxes are just a money grab. Carbon taxes are just a money grab. Carbon taxes are just a money grab.",
						"color": "#4E0F08",
						"content": "Coming Soon!"
					}
				}
			}
		}
	};

/***/ }),
/* 118 */
/***/ (function(module, exports) {

	module.exports = "<stance>\n    <!-- <p class=\"notice\">\n        <a href=\"#{{prefix}}/{{issue.permalink}}\">\n            &laquo; Review other stances on this issue\n        </a>\n    </p> -->\n\n    <h1>\n        <span class=\"dot\"></span>\n        <a href=\"#{{prefix}}/{{issue.permalink}}/{{stance.permalink}}\">\n            {{stance.title}}\n        </a>\n    </h1>\n\n    <stance-content>\n        <p>\n            {{stance.description}}\n        </p>\n    </stance-content>\n\n    <p class=\"notice-3\">\n        <a href=\"#{{prefix}}/{{issue.permalink}}\">\n            &laquo; Review other stances on this issue\n        </a>\n    </p>\n</stance>\n";

/***/ })
/******/ ]);